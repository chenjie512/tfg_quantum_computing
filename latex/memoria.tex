\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{hyperref}
%https://ctan.org/pkg/braket
\usepackage{braket}
\usepackage{comment}

\usepackage[qm]{qcircuit}
\usepackage{tikz}
\usepackage{graphicx}
\graphicspath{ {./imagen/} }

%\usepackage{biblatex}

%\usepackage{enumerate}
%\usepackage{blindtext}

\usepackage[left=3.25cm,top=3cm,right=2cm,bottom=3.25cm]{geometry}

%Nuevos entornos
\newtheorem{deff}{Definición}[section]
\newtheorem{teo}{Teorema}[section]
\newtheorem{lem}{Lema}[section]

%Enumeración
\numberwithin{equation}{section}

%Nuevo comandos
\newcommand\norm[1]{\lVert#1\rVert}
\newcommand{\modd}{\; mod \;}

\title{Computación Cuántica}
\author{Chenjie Huang}
\date{}


%Documento

\begin{document}

\begin{titlepage}
\centering
{\bfseries\LARGE Universidad Complutense de Madrid \par}
\vspace{1cm}
{\scshape\Large Facultad de Ciencias Matemáticas \par}
\vspace{0.5cm}

\includegraphics[width=0.5\textwidth]{escudo_ucm}

\vspace{0.5cm}
{\scshape\Large Trabajo de Fin de Grado \par}

\vspace{0.5cm}

{\scshape\Huge Introducción a la computación cuántica y los algoritmos cuánticos \par}
\vspace{2cm}

\vfill
{\Large Tutor: Luis Fernando Llana Díaz \par}

{\Large Autor: Chenjie Huang\par}

{\Large Grado en Matemáticas\par}

\vfill
{\Large Curso 2022/2023 \par}
\end{titlepage}

\newpage

\thispagestyle{empty}
\

\newpage
\begin{center}
\textbf{\Large Resumen}
\end{center}
\vspace{0.5cm}

La computación cuántica es el campo de estudio que combina la física, las matemáticas y la computación. Se Aprovecha del fenómeno de la superposición cuántica, en la cuál un objeto está en varios estados diferentes de manera simultánea. Con este fenómeno somos capaces de diseñar un sistema cuántico donde el principal objeto será el bit cuántico o qubit. En vez de los estados básicos $0$ y $1$, este puede estar en una superposición de los estados $\ket{0}$ y $\ket{1}$.\\
El estado de un qubit está representado por un vector de un espacio vectorial, siendo la superposición de los estados una combinación lineal de los elementos de la base
\begin{equation}
\ket{\varphi} = \alpha \ket{0} + \beta \ket{1}
\end{equation}
Podemos medir este qubit para determinar su estado, en dicho proceso el qubit colapsará en uno de los estados clásicos $0$ ó $1$.\\
Construiremos sistemas más grandes de qubits con el producto tensorial del espacio vectorial para representar sus estados. También podremos manipular los estados con puertas cuánticas, que funciona como una puerta lógica, y estarán representados con una aplicación lineal sobre el espacio vectorial. Esto lleva asociado una matriz que se le pedirá ser unitaria, es decir, el producto por su adjunta sea la matriz identidad.\\
\linebreak
Con estas herramientas podremos construir un algoritmo cuántico básico consistente en:
\begin{itemize}
\item Comenzaremos normalmente poniendo los qubits del sistema en un estado de superposición.

\item Después, aplicaremos sobre estos qubits una puerta cuántica representado por una matriz unitaria.

\item Finalmente, mediremos los estados de los qubits, para deducir una conclusión con los resultados.
\end{itemize}
Hay algoritmos más complejos que involucran más puertas cuánticas más complejas.\\

\begin{center}
\textbf{\Large Abstract}
\end{center}
\vspace{0.5cm}

The quantum computing is the field of study that combines physics, mathematics and computer science. It exploits the quantum mechanical phenomena called quantum superposition in which a object is simultaneously at different states. With this phenomena, we can design a quantum sistem where the main object is the quantum bit or qubit. Instead of the basic states $0$ and $1$ of a bit, it can be in a superposition of the states $\ket{0}$ and $\ket{1}$.\\
This state of a qubit is represented by a vector in a vectorial space, so the superposition of states is just a lineal combination of the elements of a vectorial basis
\begin{equation}
\ket{\varphi} = \alpha \ket{0} + \beta \ket{1}
\end{equation}
We can measure this qubit to determine their state, in which the qubit collapse into one of the classical states $0$ or $1$.\\
We form bigger sistem of qubits by performing their tensor product as a vector to represent their states. We can also manipulate states with quantum gates, which functions as a classical logic gate, and we represent them with lineal aplications on the vectorial space. This comes with their corresponding matrix association, which only requirements is that they must be unitary, that is, the product with their adjoint is the indentity matrix.\\
\linebreak
With all the tool, we can make basic quantum algorithm in which:
\begin{itemize}
\item We usually start by putting the qubits into superposition of many states.

\item This is followed by acting on this qubits in superposition with some unitary operations.

\item Then we measure the qubits to determine their state and reach some sort of conclusion with the results.
\end{itemize}
There is more complex algorithm which involves more complex operations.


\newpage

\tableofcontents

\newpage


\section{Introducción}

La computación cuántica es un área de estudio reciente y en desarrollo que implica otras grandes áreas de estudio como la computación, la física y la matemática. Dicho estudio se centra en los curiosos fenómenos y aspectos de la física cuántica, todo con el objetivo de expandir los límites de la computación. Esto nos ha permitido dar algunas soluciones innovadoras a problemas complejos de la computación sin resolver y desde un punto de vista totalmente nuevo.\\
\linebreak
La mecánica cuántica, base de nuestro campo que es la computación cuántica, es de las ciencias con más éxito pero a la vez desconocida. Empezando su desarrollo teórico en el siglo pasado, seguido de su su aplicación por los científicos en la observación y entendimiento de los fundamentos de las partículas y sus comportamientos, resultando incluso en el desarrollo de un modelo físico que es la física de partículas. A pesar de su aplicaciones para explicar un amplio rango de fenómenos de la naturaleza, un leve cambio en esta idea de aplicar los sistemas cuánticos en los fenómenos naturales para darles explicación da lugar a la idea de no limitarse a observar, sino a diseñar estos sistemas cuánticos. Como resultado de esto, surge un interés de nuevo por la mecánica cuántica, sobretodo en planteamiento de cuestiones que llegan a combinar otros campos de estudio como la computación y la teoría de la información.\\
\linebreak
Como veremos en detalle en poco, la idea tras la computación cuántica es aprovechar el fenómeno de la superposición cuántica, descrito en la teoría de la mecánica cuántica. Este fenómeno describe partículas que pueden estar en diferentes estados de manera simultanea, que determinaremos un estado fijo en la partícula en cuanto la observemos. Además permite interacciones con el elemento en varios estados de manera también simultanea. A pesar de que se desconoce la naturaleza y el porqué de este fenómeno, no podemos negar que esto ocurre e incluso dando lugar efectos sobre fenómenos reales. Podemos destacar en cuestión el experimento de la doble rendija, en el que pone en manifiesto el fenómeno de la superposición de varios estados, cuando el estado de un mismo elemento interacciona con otro estado de manera que a veces llega a anularlo. A esto se le conoce como interferencia, y podemos poner en similitud un ejemplo de dos guijarros tirados a un charco de agua y cómo se forma ondas en la superficie de manera que a veces se llegan a cancelar unas a otras, mientras que otras veces se llegan a reforzar una a la otra.\\
\linebreak
En vista de la computación clásica, tenemos su elemento base que es el bit, un elemento con dos estados posibles y nos permite realizar operaciones sencillas pero y si las combinamos estas da lugar a numerosas tareas complejas que puede realizar un ordenador hoy en día. La computación cuántica intentará mejorar esto introduciendo el qubit ó \textit{quantum bit}, que en vez de considerar dos estados posibles, consideraremos cualquier combinación de ellas en superposición dando lugar a infinitas combinaciones. Esto nos abrirá numerosas puertas en la computación, permitiendo por ejemplo la evaluación simultanea de una función sobre diferentes elementos, o más bien estados. Lo que nos da lugar a tareas que podremos realizar que se consideraban imposibles ya sea por su complejidad como por el tiempo requerido. Y no problemas sin importancia, pues uno de los temas que veremos es sobre la factorización de números, que es clave en la criptografía, presente en más lugares de nuestra vida diaria de la que creemos.

\subsection{Objetivos}

Este trabajo de fin de grado tiene por propósito introducir al estudiante en este campo de estudio con una popularidad creciente en los últimos años. A pesar de tocar varios detalles del área que involucra conocimientos del campo de la física, de la computación y de la matemática, se ha centrado en estas dos últimas con especial interés en la matemática recogiendo nociones sobre espacios vectoriales y productos tensoriales, que será la base matemáticas para luego elaborar los algoritmos.\\
\linebreak
Como hemos mencionado antes, no entraremos en detalle en las cuestiones físicas, no es el interés de este trabajo, sino nos centraremos con las matemáticas en la que se basa el modelo físico, dando las representaciones físicas de los elementos matemáticos que estudiaremos con sólo el fin de proporcionar otro punto de visto. Pero en el fondo, lo trataremos como un objeto matemático a la hora de trabajar.\\

\subsection{Metodología}

Por tanto, con este objetivo en mente, se procederá de la siguiente manera. Se realizará la lectura de materia propuesto por el tutor en forma de dos libros. Uno de naturaleza más sencilla para dar una idea inicial al alumno, el libro de Yanofsky\cite{yanofsky2008quantum}. Mientra que el otro, el libro de Nielsen \cite{nielsen2001quantum} que es de carácter más complejo, servirá para entrar en detalles de cuestiones más complicadas.\\
\linebreak
Se procederá entonces a la exposición y desarrollo de los conceptos que se han estudiado de los dos libros en las siguientes del documento. Esto conlleva claramente el entendimiento de estos conceptos y para ello se han realizado de manera constante numerosas tutorías ya sea para una duda puntual como para reafirmar y reforzar la idea presente en los libro. También ha servido estas tutorías como guía para organizar el trabajo y cómo llevarlo a cabo.\\
\linebreak
Además de la presentación en los contenidos de este documento, se ha procedido a la implementación de los algoritmos en Qiskit, un software que permite de manera relativamente sencilla programar los algoritmos cuánticos. Se han ejecutado simulaciones de los algoritmos además de algunas pruebas en un ordenador cuántico real. No mostraremos los códigos del algoritmo en este documento, sino los presentaremos en un repositorio abierto de GitHub \cite{chen2023github}. El enlace se encuentra en la bibliografía de este documento junto a los dos libros mencionados.\\


\newpage

\section{Preliminares}

La Teoría Cuántica se apoya principalmente sobre álgebra lineal, concretamente sobre el espacio vectorial complejo de dimensión finita $\mathbb{C}^n$.
En esta sección que servirá como preliminares como indica el título, nos centraremos en la teoría de álgebra lineal sobre el espacio vectorial complejo.\\
El objetivo es conseguir que este apartado sirva a modo de fundamento y bases para secciones posteriores y también de consulta posteriormente.

\subsection{Espacios Vectoriales}

\begin{deff}

Un espacio vectorial sobre un cuerpo $\mathbb{K}$ es un conjunto no vacío $\mathbb{V}$, cuyo elementos llamaremos vectores, y llevan asociado dos operaciones, 
\begin{itemize}

\item La Suma, $\textbf{+}: \mathbb{V} \times \mathbb{V} \longrightarrow \mathbb{V}$

\item El Producto por un escalar, $\textbf{$\cdot$}:\mathbb{K} \times \mathbb{V} \longrightarrow \mathbb{V}$

\end{itemize}
tal que $(\mathbb{V},+)$ cumple las propiedades de formar un \textbf{grupo abeliano} y el producto por un escalar $\cdot$ cumpla las propiedades de:
\begin{itemize}

\item Existencia de elemento neutro:
\begin{equation}
\exists e \in \mathbb{K} \text{ tal que } \forall v \in \mathbb{V},  e \cdot v = v
\end{equation}

\item Propiedad asociativa:
\begin{equation}
\forall a, b \in \mathbb{K}, \forall v \in \mathbb{V}, a\cdot(b\cdot v) = (a\cdot b)\cdot v
\end{equation}

\item Propiedad distributiva respecto a la suma de vectores:
\begin{equation}
\forall a \in \mathbb{K}, \forall u, v \in \mathbb{V}, a\cdot(u + v) = a\cdot u + a\cdot v
\end{equation}

\item Propiedad distributiva respecto a la suma de escalares:
\begin{equation}
\forall a, b \in \mathbb{K}, \forall v \in \mathbb{V}, (a + b)\cdot v = a\cdot v + b\cdot v
\end{equation}

\end{itemize}

\end{deff}

En el caso de que el cuerpo de escalares sea el de los complejos $\mathbb{C}$, se le denominará \textbf{espacio vectorial complejo}, siendo estas de gran interés para nuestro campo de estudio que es la mecánica cuántica.
A partir de ahora usaremos $\mathbb{C}$ como cuerpo de escalares del espacio vectorial junto a la notación estándar de mecánica cuántica para referirnos a los elementos básicos de la álgebra lineal.\\
\linebreak
Denotaremos al vector en un espacio vectorial $\mathbb{V}$ como $\ket{v}$, donde usaremos $\ket{\cdot}$ para indicar que es un vector del espacio, denominado \textbf{\textit{ket}}.\\
En cuanto al elemento neutro del espacio vectorial, el vector cero, lo denotaremos excepcionalmente como $\mathbf{0}$. Veremos posteriormente que usaremos $\ket{0}$ para referirnos a algo completamente diferente.\\
Centrándonos más en $\mathbb{C}^n$, el espacio vectorial complejo cuyo elementos son $n$-tuplas $(z_1, z_2, \ldots z_n)$, usaremos a veces la notación de vector columna:
$$\begin{bmatrix}
z_1 \\ z_2 \\ \vdots \\ z_n
\end{bmatrix}$$

\subsection{Bases y dimensión}

\begin{deff} Sea $\ket{v_1},\ket{v_2}, \ldots, \ket{v_n}$ vectores de un cierto espacio vectorial $\mathbb{V}$ sobre $\mathbb{C}$. Diremos que un vector $\ket{v}\in\mathbb{V}$ es \textbf{combinación lineal} de ellos si existen $a_1, a_2, \ldots, a_n \in \mathbb{C}$ escalares tal que podemos escribir $\ket{v}$ como:
\begin{equation}
\ket{v} = \sum_{i=1}^n a_i \cdot \ket{v_i}
\end{equation}
\end{deff}

\begin{deff} Sea $\{ \ket{v_1},\ket{v_2}, \ldots, \ket{v_n} \}$ un conjunto de vectores de un cierto espacio vectorial $\mathbb{V}$ sobre $\mathbb{C}$. Diremos que son \textbf{linealmente dependientes} si existen $a_1, a_2, \ldots, a_n \in \mathbb{C}$, con algún $a_i \neq 0$, tal que
\begin{equation}
a_1\ket{v_1} + a_2\ket{v_2} + \ldots + a_n\ket{v_n} = 0
\end{equation}
Además diremos que son \textbf{linealmente independientes} si no son linealmente dependientes. Es decir, si existe una combinación lineal de ellos, entonces los coeficientes son todos nulos.
\end{deff}

\begin{deff} Llamaremos entonces al conjunto $B = \{ \ket{v_1},\ket{v_2}, \ldots, \ket{v_n} \}$ \textbf{base} del espacio $\mathbb{V}$ si:
\begin{itemize}
\item $B$ es linealmente independiente.

\item $\forall \ket{v} \in \mathbb{V}$, $\ket{v}$ puede ser escrito como combinación lineal de vectores de $B$.
\end{itemize}
\end{deff}

Además podemos asegurar la existencia de este conjunto para todo espacio vectorial. Y también de que el número de elementos de dos bases distintas del mismo espacio vectorial coincide y nos referiremos a este número como \textbf{dimensión} del espacio $\mathbb{V}$.
\\
Como hemos hecho mención antes, nuestro interés se halla en espacios vectoriales de dimensión finita, por tanto haremos omiso de las cuestiones relacionadas con espacios de dimensión infinita.

\subsection{Aplicaciones lineales y forma matricial}

\begin{deff} Una aplicación lineal entre dos espacios vectoriales $\mathbb{V}$ y $\mathbb{W}$ sobre el mismo cuerpo $\mathbb{C}$ es una aplicación $f: \mathbb{V} \longrightarrow \mathbb{W}$ tal que es lineal sobre sus componentes, es decir, si $\ket{v} = \sum_{i=1}^n a_i \cdot \ket{v_i}$ entonces se cumple:
\begin{equation} \label{eq7}
f(\ket{v}) = f(\sum_{i=1}^n a_i \cdot \ket{v_i}) = \sum_{i=1}^n a_i \cdot f(\ket{v_i})
\end{equation}

Diremos además que una aplicación lineal está definida sobre $\mathbb{V}$ para referirnos a que es una aplicación lineal de $\mathbb{V}$ a $\mathbb{V}$
\end{deff}
Un aplicación de gran importancia es la aplicación identidad, que denotaremos con $id_{\mathbb{V}}$ y cumple la propiedad de que $\forall \ket{v}\in\mathbb{V}$, $id_{\mathbb{V}}(\ket{v}) = \ket{v}$.
\\
Observando la expresión \ref{eq7} podemos llegar a la conclusión de que una aplicación lineal está completamente determinada por su acción sobre los elementos de una base, pues todo vector se puede expresar como combinación lineal de los vectores de una base.
\\
Una manera muy útil de expresar una aplicación lineal es a través de su expresión matricial. Veamos esto con la aplicación de $f:\mathbb{V} \longrightarrow \mathbb{W}$ sobre los vectores de las bases correspondientes. Sea $\{ \ket{v_1}, \ldots, \ket{v_m} \}$ y $\{ \ket{w_1}, \ldots, \ket{w_n} \}$ bases correspondientes a $\mathbb{V}$ y $\mathbb{W}$.
\\
Entonces para cada j de $1$ a $m$ existirán $a_{1j}, \ldots, a_{nj} \in \mathbb{C}$ tal que
\begin{equation} \label{eq8}
f(\ket{v_j}) = \sum_{i=1}^n a_{ij} \ket{w_i}
\end{equation}
por ser $f(\ket{v_j}) \in \mathbb{W}$ y $\{ \ket{w_1}, \ldots, \ket{w_n} \}$ base de $\mathbb{W}$.

\begin{deff}Llamaremos entonces $A$ a la matriz formada por los elementos $a_{ij}$ de la ecuación \ref{eq8} en la posición $(ij)$ en la matriz, como representación matricial de la función $f$.
\end{deff}

Además, tomando las \textbf{coordenadas} $\boldsymbol{z_j}$ de un vector $\ket{v} = \sum_{j=1}^m \boldsymbol{z_j} \ket{v_j}$ de $\mathbb{V}$ y su imagen por $f$ con la expresión \ref{eq8}:
\begin{equation}
f(\ket{v}) = f(\sum_{j=1}^m z_j \ket{v_j}) = \sum_{j=1}^m z_j f(\ket{v_j}) = \sum_{j=1}^m z_j (\sum_{i=1}^n a_{ij} \ket{w_i}) = 
\sum_{i=1}^n (\sum_{j=1}^m a_{ij} z_{j}) \ket{w_i}
\end{equation}
podemos observar la aplicación de $f$ sobre el vector $\ket{v}$ no es más que el producto de la matriz $A$ con el vector $\ket{v}$ en columnas:
\begin{equation}
A\ket{v} = 
\begin{bmatrix}
a_{11} & a_{12} &\ldots & a_{1m} \\
a_{21} & a_{22} &\ldots & a_{2m} \\
\vdots & \vdots &\ddots & \vdots \\
a_{n1} & a_{n2} &\ldots & a_{nm}
\end{bmatrix}
\begin{bmatrix}
z_1 \\ z_2 \\ \vdots \\ z_m
\end{bmatrix} =
\begin{bmatrix}
\sum_{j=1}^m a_{1j}z_j \\
\sum_{j=1}^m a_{2j}z_j \\
\vdots \\
\sum_{j=1}^m a_{nj}z_j \\
\end{bmatrix}
\end{equation}

\subsection{Producto Escalar y Espacios de Hilbert}

\begin{deff}Un \textbf{producto escalar}, o también conocido como producto interno, es una aplicación $(\cdot, \cdot): \mathbb{V}\times\mathbb{V} \longrightarrow \mathbb{C}$ que cumple:
\begin{itemize}

\item Es definida positiva,
\begin{equation}
(\ket{v}, \ket{v}) \geq 0
\end{equation} y
\begin{equation}
(\ket{v}, \ket{v}) = 0 \Leftrightarrow \ket{v} = 0
\end{equation}

\item Es lineal en el primer argumento y lineal conjugada en el segundo,
\begin{equation}
(a\ket{u} + b\ket{v}, \ket{w}) = \bar{a} \cdot(\ket{u}, \ket{w}) + \bar{b} \cdot(\ket{v}, \ket{w})
\end{equation}
\begin{equation}
(\ket{u}, a\ket{v} + b\ket{w}) = a \cdot (\ket{u}, \ket{v}) + b \cdot (\ket{u}, \ket{w})
\end{equation}

\item Es anti-simétrico,
\begin{equation}
(\ket{u}, \ket{v}) = \overline{(\ket{v}, \ket{u})}
\end{equation}
\end{itemize}
donde $a,b \in \mathbb{C}$, $\ket{u}, \ket{v}, \ket{w} \in \mathbb{V}$ y $\bar{a} \in \mathbb{C}$ es el conjugado complejo del elemento $a$.
\end{deff}
La notación estándar del producto escalar en mecánica cuántica no es $(\ket{u}, \ket{v})$, sino $\braket{u|v}$, donde $\ket{u}$ y $\ket{v}$ son vectores de $\mathbb{V}$ y $\bra{u}$ denota el vector dual al vector $\ket{u}$, también conocido como \textbf{bra}. El dual es una aplicación lineal cuya definición es $\bra{u}(\ket{v}) := \braket{u|v} = (\ket{u},\ket{v})$. A partir de ahora, usaremos más esta notación.

\begin{deff}Diremos que dos vectores $\ket{u}$ y $\ket{v}$ son \textbf{ortogonales} si su producto escalar es 0.
\\
Además definiremos como \textbf{norma} del vector como 
\begin{equation}
\norm{\ket{v}} = \sqrt{\braket{v|v}}
\end{equation}
y diremos que $\ket{v}$ es unitario o normalizado si $\norm{\ket{v}} = 1$.
\end{deff}

\begin{deff}Por tanto diremos que un conjunto, $\ket{i} \in \mathbb{V}$ de vectores es \textbf{ortonormal} si son vectores unitarios y además son ortogonales entre sí. Es decir,
\begin{equation}
\forall \ket{i},\ket{j} \in \mathbb{V} \:
\braket{i|j} = \delta_{ij} = \left\{ 
\begin{array}{lcc}
1 & si & i = j \\
0 & si & i \neq j
\end{array} \right.
\end{equation}
\end{deff}

Un espacio vectorial euclídeo no es más que un espacio vectorial dotado de un producto escalar. Trabajaremos a partir de ahora en un espacio vectorial complejo de dimensión finita y con un producto escalar. Dicho espacio es denominado usualmente como \textbf{espacio de Hilbert}.

%\begin{deff}\textbf{Espacio de Hilbert}
%(falta)(y buscar referencia)
%\end{deff}

En nuestro caso por la finitud de la dimensión, un espacio de Hilbert es equivalente a espacio euclídeo.
No entraremos en detalles en el caso de que la dimensión sea infinita, ya que para hablar de espacio de Hilbert sería necesario que se cumplan alguna propiedad extra. Nos centraremos en el caso de la dimensión finita cuando hablemos de espacio de Hilbert.\\
\linebreak
Podemos ver ahora que el producto escalar en un espacio de Hilbert tiene una representación matricial muy útil.
Consideramos $\ket{u} = \sum_i u_i\ket{i}$ y $\ket{v} = \sum_j v_j\ket{j}$ con $\ket{i}, \ket{j}$ vectores de una base ortonormal $\{ \ket{1}, \ket{2}, \ldots, \ket{n} \}$.
Entonces el producto escalar,
\begin{equation}
\braket{u|v} = (\sum_i u_i\ket{i}, \sum_j v_j\ket{j}) = \sum_{ij} \bar{u_i} v_j\braket{i|j} = \sum_{ij} \bar{u_i} v_j\delta_{ij} = \sum_i \bar{u_i} v_i
\end{equation}
que claramente es el producto entre un vector fila conjugado y uno columna,
\begin{equation}
\braket{u|v} =
\left[ \bar{u_1}  \bar{u_2}  \ldots  \bar{u_n} \right]
\begin{bmatrix}
v_1 \\ v_2 \\ \vdots \\ v_n
\end{bmatrix} =
\sum_i \bar{u_i} v_i
\end{equation}
Podemos observar también que el vector dual $\bra{u}$ se puede expresar como un vector fila cuyas componentes están conjugadas.
\\
Una manera útil de ver las aplicaciones lineales es a través de su representación como \textbf{producto exterior}.

\begin{deff}Llamaremos producto exterior a la aplicación $\ket{u}\bra{v}: \mathbb{V} \longrightarrow \mathbb{W}$, donde $\ket{v} \in \mathbb{V}$ y $\ket{u} \in \mathbb{W}$,
\begin{equation}
\ket{u}\bra{v}(\ket{v'}) = \ket{u}\braket{v|v'} = \braket{v|v'} \cdot \ket{u}
\end{equation}
\end{deff}
Considerando ahora una base ortonormal $\{\ket{i}\}_{1\leq i\leq n}$, podemos deducir la propiedad de completitud del producto exterior. Sea el vector $\ket{v} = \sum_i v_i\ket{i}$, teniendo en cuenta que $\braket{i|v} = v_i$, tenemos que la aplicación de $\sum_i \ket{i}\bra{i}$ sobre el vector
\begin{equation}
(\sum_i \ket{i}\bra{i}) (\ket{v}) = \sum_i \ket{i}\braket{i|v} = \sum_i v_i \ket{i} = \ket{v}
\end{equation}
Lo que nos permite llegar a la conclusión de que $\sum_i \ket{i}\bra{i}$ es equivalente a la identidad.
\\
Teniendo en cuenta esta propiedad podemos conseguir la expresión de un aplicación lineal $f: \mathbb{V} \longrightarrow \mathbb{W}$, considerando $\ket{v_i}$ y $\ket{w_j}$ un base ortonormal de ambos espacios. Con la propiedad de completitud tenemos que
\begin{equation}
f \equiv id_{\mathbb{W}} \circ f \circ id_{\mathbb{V}} \equiv
\sum_{ij} (\ket{w_j}\bra{w_j}) \circ f \circ (\ket{v_i}\bra{v_i}) \equiv \sum_{ij} \braket{w_j|f(v_i)} \ket{w_j}\bra{v_i}
\end{equation}
donde podemos concluir que el valor $\braket{w_j|f(v_i)}$ es el elemento de la columna $i$ y fila $j$ de la representación matricial de $f$ en las bases correspondientes.
\\
Además observamos que esto concuerda con la expresión de un vector y su dual como vector fila y columna pues el producto resultante de
\begin{equation}
\begin{bmatrix}
w_1 \\ \vdots \\ w_n
\end{bmatrix}
\left[ v_1 \ldots v_n \right]
= \begin{bmatrix}
w_1 v_1 & \ldots & w_1 v_n \\
\vdots & \ddots & \vdots \\
w_n v_1 & \ldots & w_n v_n
\end{bmatrix}
\end{equation} es una matriz, correspondiente a la aplicación lineal.

\subsection{Matrices Adjuntas o Hermitianas}
Veremos ahora un tipo de matriz y su función asociada que se comporta de una manera muy buena con el espacio de Hilbert.

\begin{deff}Consideramos una matriz $A \in \mathbb{C}^{n\times n}$, definiremos su \textbf{adjunta} o \textbf{conjugada Hermitiana} como la matriz traspuesta con los elementos conjugados y lo denotaremos como $A^\dagger = \overline{A^T}$
\\
Además diremos que $A$ es \textbf{hermintiana} si $A^\dagger = A$ y llamaremos a la aplicación lineal asociada, aplicación \textbf{auto-adjunta}.

\end{deff}
Podemos ver fácilmente que este tipo de matrices cumplen ciertas propiedades,
\begin{itemize}

\item $\forall \ket{u}, \ket{v} \in \mathbb{V}$
\begin{equation}
(\ket{u}, A \ket{w}) = (A^\dagger \ket{u},\ket{w})
\end{equation}

\item Definiremos por convenio la adjunta de un vector $\ket{v}^\dagger = \bra{v}$, que concuerda con toda la notación que hemos estado usando. De esta manera, teniendo en cuenta que $(AB)^\dagger = B^\dagger A^\dagger$, tenemos que
\begin{equation}
(A\ket{v})^\dagger = \bra{v}A^\dagger
\end{equation}
\end{itemize}
Otras matrices que nos interesan son las matrices \textbf{unitarias}. Son un tipo de matrices invertibles que cumplen que
\begin{equation}
U * U^\dagger = U^\dagger * U = I_n
\end{equation}

\subsection{Producto Tensorial}

En esta sección estudiaremos el producto tensorial entre espacios vectoriales, una herramienta esencial para trabajar con sistemas cuánticos de varios elementos en esta área. Hablaremos de estos sistemas en secciones posteriores, por ahora nos centraremos en el producto tensorial.

\begin{deff}
Consideramos $\mathbb{V}$ y $\mathbb{W}$ dos espacios vectoriales, llamaremos \textbf{producto escalar} a la aplicación \underline{bilineal} $\otimes : \mathbb{V}\times \mathbb{W} \longrightarrow \mathbb{V}\otimes \mathbb{W}$, que lleva $\ket{v} \in \mathbb{V}$ y $\ket{w} \in \mathbb{W}$ a un elemento de $\mathbb{V} \otimes \mathbb{W}$ que llamaremos \textbf{tensor} y lo denotaremos por $\ket{v}\otimes \ket{w}$, o de manera abreviada $\ket{v}\ket{w}$, $\ket{vw}$.
\end{deff}
Además esta aplicación cumple las siguientes propiedades:
\begin{itemize}
\item Sea $z$ un escalar y $\ket{v}$ y $\ket{w}$ elementos de $\mathbb{V}$ y $\mathbb{W}$ respectivamente,
\begin{equation}
z(\ket{v}\otimes\ket{w}) = (z\ket{v})\otimes\ket{w} = \ket{v}\otimes(z\ket{w})
\end{equation}

\item Para $\ket{v_1}$, $\ket{v_2} \in \mathbb{V}$ y $\ket{w} \in \mathbb{W}$ se tiene,
\begin{equation}
(\ket{v_1} + \ket{v_2}) \otimes \ket{w} = \ket{v_1}\otimes\ket{w} + \ket{v_2}\otimes\ket{w}
\end{equation}

\item Para $\ket{v} \in \mathbb{V}$ y $\ket{w_1}$, $\ket{w_2} \in \mathbb{W}$ se tiene,
\begin{equation}
\ket{v}\otimes (\ket{w_1} +  \ket{w_2}) = \ket{v}\otimes\ket{w_1} + \ket{v}\otimes\ket{w_2}
\end{equation}

\end{itemize}
El espacio de la imagen sigue siendo un espacio vectorial y de hecho, si tomamos $\lbrace \ket{v_1}, \ldots, \ket{v_m} \rbrace$ y $\lbrace \ket{w_1}, \ldots, \ket{w_n} \rbrace$ como bases de $\mathbb{V}$ y $\mathbb{W}$ respectivamente, tenemos que
\begin{equation}
\lbrace \ket{v_i}\otimes\ket{w_j} \mid 1\leq i \leq m, 1\leq j \leq n \rbrace
\end{equation}
es una base de $\mathbb{V}\otimes\mathbb{W}$. Y por tanto, la dimensión como espacio vectorial de $\mathbb{V}\otimes\mathbb{W}$ es $m\cdot n$ siendo $m$ y $n$ la dimensión de $\mathbb{V}$ y $\mathbb{W}$ respectivamente.
\\
Las aplicaciones lineales del espacio $\mathbb{V}\otimes\mathbb{W}$ que consideraremos serán aquellas resultantes del producto tensorial de dos aplicaciones lineales del espacio de los factores, de manera que cumplan
\begin{equation} \label{prtensorial_aplineal}
(f\otimes g) (\ket{v}\otimes\ket{w}) = f(\ket{v}) \otimes g(\ket{w}).
\end{equation}
De hecho, toda aplicación lineal de $\mathbb{V}\otimes\mathbb{W}$ se puede representar como combinación lineal de aplicaciones de $\mathbb{V}$ y $\mathbb{W}$ con el producto tensorial, actuando como espacio resultante del producto tensorial del espacio de los endomorfismos.
\\
En cuanto a la práctica resulta muy cómodo trabajar con la representación matricial de estas aplicaciones y el producto de Kronecker. Pues si consideramos $A$ una matriz $m\times n$ y $B$ una matriz $p\times q$, su producto tensorial sería:
\begin{equation}
A\otimes B =
\begin{bmatrix}
a_{11}B & a_{12}B & \ldots & a_{1n}B \\
a_{21}B & a_{22}B & \ldots & a_{2n}B \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1}B & a_{m2}B & \ldots & a_{mn}B \\
\end{bmatrix}
\end{equation}
donde $a_{ij}$ es el elemento de la posición $(ij)$ de la matriz A.
\\
De la misma manera se puede operar con los vectores columnas del espacio vectorial $\mathbb{C}^n$. Por ejemplo, si tenemos $\ket{v} y \ket{w}$ vectores de $\mathbb{C}^n$ y $v_1, v_2, \ldots, v_n$, $w_1, w_2, \ldots, w_n$ sus coordenadas respectivamente en una base. Entonces su producto tensorial en forma matricial sería,
\begin{equation}
\begin{bmatrix}
	v_1 \\ v_2 \\ \vdots \\ v_n
\end{bmatrix} \otimes
\begin{bmatrix}
	w_1 \\ w_2 \\ \vdots \\ w_n
\end{bmatrix} =
\begin{bmatrix}
	v_1 \cdot \begin{bmatrix}
		w_1 \\ w_2 \\ \vdots \\ w_n
	\end{bmatrix} \\
	v_2 \cdot \begin{bmatrix}
		w_1 \\ w_2 \\ \vdots \\ w_n
	\end{bmatrix} \\
	\vdots \\
	v_n \cdot \begin{bmatrix}
		w_1 \\ w_2 \\ \vdots \\ w_n
	\end{bmatrix}
\end{bmatrix} =
\begin{bmatrix}
v_1w_1 \\ v_1w_2 \\ \vdots \\ v_1w_n \\
v_2w_1 \\ v_2w_2 \\ \vdots \\ v_2w_n \\
v_nw_1 \\ v_nw_2 \\ \vdots \\ v_nw_n
\end{bmatrix}
\end{equation}

%Aplicaciones lineales y matrices[x]

%Bases[x]

%Producto escalar[x]

%Autovalores y autovectores puede ser.[Por ahora no]

%Matrices Adjuntas o Hermitian(buscar traducción)

%Producto tensorial

\newpage

\section{Estructuras y Puertas Cuánticas}

En esta sección veremos el sistema de información en el que se basa la computación cuántica y su representación matemática. Igual que en la computación clásica se basa en el concepto de bit, en la computación cuántica se estudiará el \textbf{bit cuántico} o \textbf{qubit} (de quantum bit en inglés). Es verdad que el qubit, al igual que el bit, son objetos físicos de un sistema físico real como partículas subatómicas en un ordenador cuántico. Pero nosotros nos centraremos en describir el qubit como un objeto matemático abstracto con ciertas propiedades determinadas.


\subsection{Qubit}

Conocemos el concepto de bit, que es un elemento de un sistema con dos estados posibles. Estos dos estados son generalmente denominados como "verdadero" o "falso, o incluso con $0$ o $1$.
\begin{deff}Entonces llamaremos \textbf{qubit} al objeto matemático con dos posibles estados correspondientes al bit clásico $\ket{0}$ y $\ket{1}$, además de una combinación lineal de estos dos estados que llamaremos como \textbf{superposición}:
\begin{equation}
\ket{\varphi} = \alpha\ket{0} + \beta\ket{1}
\end{equation}
Con $\alpha$ y $\beta$ números complejos que cumplen que $|\alpha|^2 + |\beta|^2 = 1$.
\end{deff}
Se entiende fácilmente el estado de un qubit como un vector del espacio vectorial complejo de dimensión 2, restringido a la circunferencia unidad, donde los estados $\ket{0}$ y $\ket{1}$ son los elementos de la base ortonormal del espacio con $\alpha$ y $\beta$ como coordenadas del vector de norma 1.

\begin{figure}[h]
	\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-0.5,xscale=0.5]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Circle [id:dp931798172156461] 
\draw   (198,152.5) .. controls (198,90.92) and (247.92,41) .. (309.5,41) .. controls (371.08,41) and (421,90.92) .. (421,152.5) .. controls (421,214.08) and (371.08,264) .. (309.5,264) .. controls (247.92,264) and (198,214.08) .. (198,152.5) -- cycle ;
%Straight Lines [id:da9642706265204986] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (198,152.5) -- (421,152.5) ;
%Straight Lines [id:da48160384496840947] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (309.5,264) -- (309.5,41) ;
%Straight Lines [id:da8747207133103256] 
\draw    (309.5,152.5) -- (419,152.5) ;
\draw [shift={(421,152.5)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da7616528840577454] 
\draw    (309.5,152.5) -- (390.28,76.17) ;
\draw [shift={(391.73,74.8)}, rotate = 136.62] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da30485545720038276] 
\draw    (309.5,152.5) -- (309.5,43) ;
\draw [shift={(309.5,41)}, rotate = 90] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (402,59.93) node [anchor=north west][inner sep=0.75pt]    {$|\varphi \rangle $};
% Text Node
\draw (299.33,5.93) node [anchor=north west][inner sep=0.75pt]    {$|1\rangle $};
% Text Node
\draw (429.33,144.6) node [anchor=north west][inner sep=0.75pt]    {$|0\rangle $};


\end{tikzpicture}
\end{figure}

Podemos determinar el estado de un bit clásico a la hora de examinarlo, pero en el caso del qubit, no podemos determinar el estado cuántico de un qubit en superposición, es decir, no podemos hallar el valor de $\alpha$ y $\beta$. Lo que sí podemos hacer es \textbf{medir} el qubit, determinar si colapsa en el estado $\ket{0}$ con probabilidad $|\alpha|^2$ ó en el estado $\ket{1}$ con probabilidad $|\beta|^2$. En otra palabras, el proceso de medir un qubit, nos devuelve como salida un estado clásico al que colapsa y deja de estar en superposición de varios estados de manera simultanea.\\
\linebreak
Veamos ahora otra representación geométrica del qubit que puede resultar útil. Consideramos un qubit en estado de superposición.
\begin{equation}
\ket{\psi} = c_0\ket{0} + c_1\ket{1} 
\end{equation}
con $\|c_0|^2 + |c_1|^2 = 1$. Reescribimos la expresión en coordenadas en forma exponencial de un número complejo,
\begin{equation}
\ket{\psi} = r_0 e^{i\varphi_0}\ket{0} + r_1 e^{i\varphi_1}\ket{1}
\end{equation}
Lo multiplicamos por un escalar de módulo 1, así no alteramos su estado cuántico,
\begin{equation}
e^{-i\varphi_0}\ket{\psi} = e^{-i\varphi_0}(r_0 e^{i\varphi_0}\ket{0} + r_1 e^{i\varphi_1}\ket{1}) = 
r_0\ket{0} + r_1 e^{i(\varphi_1 - \varphi_0)}\ket{1}
\end{equation}
Tomando ahora coordenadas polares $r_0 = \cos(\theta)$, $r_1 = \sin(\theta)$ y el cambio de variables $\varphi = \varphi_1 - \varphi_0$, resulta en la siguiente expresión,
\begin{equation}
\ket{\psi} = \cos(\theta)\ket{0} + e^{i\varphi}\sin(\theta)\ket{1}
\end{equation}
Considerando $\theta$ y $\varphi$ como coordenadas de un punto en una esfera tridimensional, podemos ver el estado del qubit como un punto en la superficie de dicha esfera, siendo los polos los estados $\ket{0}$ y $\ket{1}$. Esta esfera recibe el nombre de \textbf{esfera de Bloch} y veremos en poco que con ella podemos representar operaciones de qubits como rotaciones de la esfera.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{esfera_bloch}
	\caption{Esfera de Bloch. Fuente: Yanofsky \cite{yanofsky2008quantum}}
\end{figure}


\subsection{Sistema de Varios Qubits}

Tomamos interés en un sistema de un número mayor de qubits, que enlazaremos a través del producto tensorial de los espacios vectoriales. Por tanto un elemento de él estará representado por un vector de $\mathbb{C}^2 \otimes \mathbb{C}^2 \otimes \ldots \otimes \mathbb{C}^2$ que denotaremos como $(\mathbb{C}^2)^{\otimes n}$ donde $n$ es el número de qubits del sistema y cuya dimensión como espacio vectorial es $2^n$.\\
\linebreak
Por ejemplo, si queremos un sistema de 2 qubits en comparación a los estados clásicos de un bit tendríamos 00, 01, 10 y 11, por tanto nuestro sistema de 2 qubits tendría los estados $\ket{00}$, $\ket{01}$, $\ket{10}$ y $\ket{11}$ que se corresponden con el producto tensorial del estado de los dos qubits $\ket{x}\otimes\ket{y}$ con $x$, $y\in \lbrace 0, 1\rbrace$.
Vamos a trabajar más cómodamente con coordenadas del vector en su expresión matricial, consideramos primero,
\begin{equation}
\ket{0} = \begin{bmatrix}
	1 \\ 0
\end{bmatrix}, \ 
\ket{1} = \begin{bmatrix}
	0 \\ 1
\end{bmatrix}
\end{equation}
Como hemos visto en la sección anterior, aplicaremos el producto de  Kroner para obtener las expresiones matriciales de $\ket{00}$, $\ket{01}$, $\ket{10}$ y $\ket{11}$,
\begin{equation}
\ket{00} =
\begin{bmatrix}
	1 \\ 0 \\ 0 \\ 0
\end{bmatrix}, \ 
\ket{01} =
\begin{bmatrix}
	0 \\ 1 \\ 0 \\ 0
\end{bmatrix}, \ 
\ket{10} =
\begin{bmatrix}
	0 \\ 0 \\ 1 \\ 0
\end{bmatrix}, \ 
\ket{11} =
\begin{bmatrix}
	0 \\ 0 \\ 0 \\ 1
\end{bmatrix}
\end{equation}
Observamos que forman una base ortonormal de un espacio vectorial de dimensión $2^2 = 4$ y que además cada coordenada corresponde a un estado clásico del qubit:
\begin{equation}
\ket{01} =
\begin{matrix}
	\textbf{00} \\ \textbf{01} \\ \textbf{10} \\ \textbf{11}
\end{matrix}
\begin{bmatrix}
	0 \\ 1 \\ 0 \\ 0
\end{bmatrix}
\end{equation}
Por tanto, si tomamos un sistema de dos qubits arbitrario en superposición,
\begin{equation}
\ket{\psi} = c_0 \ket{00} + c_1 \ket{01} + c_2 \ket{10} + c_3 \ket{11}
\end{equation}
su representación matricial sería:
\begin{equation}
\ket{\psi} =
\begin{matrix}
	\textbf{00} \\ \textbf{01} \\ \textbf{10} \\ \textbf{11}
\end{matrix}
\begin{bmatrix}
	c_0 \\ c_1 \\ c_2 \\ c_3
\end{bmatrix}
\end{equation}
Trabajaremos a partir de ahora con la notación del sistema de varios qubits como $\ket{xy}$, $\ket{x\otimes y}$, ó $\ket{x}\otimes\ket{y}$ y los trataremos de manera indiferente según convenga.\\

Podemos medir únicamente un subconjunto de qubits del sistema total siendo la probabilidad de obtener el qubit en un estado concreto la suma de las probabilidades del estado del sistema con el qubit correspondiente en el estado en concreto. Por ejemplo si tomamos el sistema de dos qubits anterior, la probabilidad de que el primer qubit esté en el estado $\ket{0}$ será $|c_0|^2 + |c_1|^2$ que son las probabilidades de que el sistema esté en el estado $\ket{00}$ ó $\ket{01}$. Hacemos notar que tras medirlo, el sistema quedará en el estado
\begin{equation}
\ket{\psi'} = \frac{c_0\ket{00} + c_1\ket{01}}{\sqrt{|c_0|^2 + |c_1|^2}}
\end{equation}
ya que hemos determinado el estado del primer qubit haciéndolo colapsar a un estado clásico a la hora de medirlo. Además, el denominador $\sqrt{|c_0|^2 + |c_1|^2}$ se debe por normalizar el vector que representa el estado del sistema. Recordemos que esto era una condición necesaria que tenemos que pedir.
Un ejemplo importante de un sistema de dos qubits es el \textbf{estado de Bell} ó \textbf{par ERP},
\begin{equation}
\frac{\ket{00} + \ket{11}}{\sqrt{2}}
\end{equation}
que nos muestra una propiedad importante de los sistemas de varios qubits a la hora de hacer mediciones. Si medimos el primer qubit tendrá una probabilidad de $(\frac{1}{\sqrt{2}})^2 = \frac{1}{2}$ de estar en el estado $\ket{0}$ y una probabilidad de $\frac{1}{2}$ de estar en el estado $\ket{1}$. Esto dejará el sistema en el estado $\ket{\psi'} = \ket{00}$ ó $\ket{\psi'} = \ket{11}$. En cualquier caso tenemos que ambas situaciones, tras medir el primer qubit, si medimos el segundo este coincidirá con el primero. Es decir, que ambos qubits está enlazados.\\
\linebreak
Nos fijamos un momento en la dimensión del espacio vectorial que representa nuestro sistema. Supongamos que tenemos un número de un tamaño considerable de qubits, $n=500$. Si quisiéramos simular este sistema en un ordenador clásico realizando las operaciones matriciales necesarias en la computación, tendríamos que para un estado del sistema almacenar $2^{500}$ coordenadas complejas del vector además de trabajar con matrices de tamaño $2^{500}$. Esto claramente no es factible hoy en día resultando en una de los problemas en cuanto a la computación cuántica.

\subsection{Circuitos y Puertas Cuánticas}

Al igual que un circuito de un ordenador clásico consiste en cables y puertas lógicas que interaccionan con la información que es transportada por el cableado, un circuito cuántico consiste en cables que transportan información cuántica en forma de qubits que son manipulados a través de puertas cuánticas.\\
\linebreak
Consideremos primero la puerta clásica \textbf{NOT} que queremos que realice la operación de la tabla de verdad sobre un bit, es decir,
\begin{equation}
\begin{cases}
0 \rightarrow 1 \\
1 \rightarrow 0
\end{cases}
\end{equation}
intercambiando los estados 0 y 1. Queremos que nuestra puerta cuántica se comporte de la misma manera sobre qubits. Queremos que intercambie los estados $\ket{0}$ y $\ket{1}$ y además por ser puerta cuántica pediremos que sea lineal, es decir, si tenemos un un qubit arbitrario en estado de superposición
\begin{equation}
\alpha\ket{0} + \beta\ket{1}
\end{equation}
queremos que se aplique de forma lineal a cada uno de los términos de la suma,
\begin{equation}
\alpha\ket{1} + \beta\ket{0}.
\end{equation}
Igual que hemos asociado con vectores a los bits, y podemos operar con los vectores de forma matricial, las puertas lógicas están asociados a las matrices.
Por tanto si tomamos la matriz $\textrm{NOT} = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$, esta matriz cumple que
\begin{equation}
\begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
\begin{bmatrix}
1 \\ 0
\end{bmatrix} =
\begin{bmatrix}
0 \\ 1
\end{bmatrix}
\textrm{ y }
\begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
\begin{bmatrix}
0 \\ 1
\end{bmatrix} =
\begin{bmatrix}
1 \\ 0
\end{bmatrix}
\end{equation}
tomando el vector correspondiente al estado cuántico $\ket{0}$ y $\ket{1}$ y los intercambia:
\begin{equation}
\textrm{NOT} \ket{0} = \ket{1} \textrm{ y } \textrm{NOT}\ket{1} = \ket{0}
\end{equation}
Otra propiedad que les pediremos a las puertas cuánticas es que sean reversibles. Esto es que dados la salida y la operación aplicada seamos capaces de determinar la entrada del circuito. Representaremos las puertas cuánticas con matrices unitarias que son reversibles por su propia adjunta. Recordemos que esto es:
\begin{equation}
U * U^\dagger = U^\dagger * U = I_n
\end{equation}
Podemos poner de ejemplo, la operación AND, que toma dos bits y nos devuelve 1 si ambos inputs son 1. Esta operación no es reversible, ya que si conocemos solamente el output, no podemos determinar cuál ha sido el input de la operación. \\
De esta manera tenemos que, aparte de la propiedad de ser lineal que está implicada, cualquier matriz unitaria lleva asociada su puerta cuántica correspondiente, siendo el único requisito que pediremos.
Veamos otras puertas cuánticas de un qubits de importancia. Si consideramos las matrices de Pauli,
\begin{equation}
X = \begin{bmatrix}
	0 & 1 \\
	1 & 0
\end{bmatrix}, \ 
Y = \begin{bmatrix}
	0 & -i \\
	i & 0
\end{bmatrix}, \ 
Z = \begin{bmatrix}
	1 & 0 \\
	0 & -1
\end{bmatrix},
\end{equation}
tendremos que cada una de ellas tiene asociado una puerta cuántica correspondiente. De hecho, la matriz X corresponde con la puerta NOT. Podemos evaluar la matriz con los estados del qubit para determinar su comportamiento, pues por ejemplo si tomamos la matriz Z,
\begin{equation}
Z(\alpha\ket{0} + \beta\ket{1}) = 
\begin{bmatrix}
	1 & 0 \\
	0 & -1 
\end{bmatrix}
\begin{bmatrix}
	\alpha \\ \beta
\end{bmatrix} =
\begin{bmatrix}
	\alpha \\ -\beta
\end{bmatrix} =
\alpha\ket{0} - \beta\ket{1},
\end{equation}
que cambia el signo del coeficiente de $\ket{1}$.\\
Otra manera de visualizar estas puertas es como rotaciones de $180º$ sobre la esfera de Bloch en el eje correspondiente. \\
\begin{figure}[h]
	\centering
	\includegraphics[scale=.65]{rotacion_bloch}
	\caption{Rotación sobre el eje Y en la esfera de Bloch. Fuente: Yanofsky \cite{yanofsky2008quantum}}
\end{figure}\\
Una puerta cuántica de mucha importancia es la puerta de Hadamard ya que nos permitirá poner qubit en una configuración en la que todos los estados son equiprobables. Esta puerta tiene por matriz:
\begin{equation}
\frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix},
\end{equation}
que lleva
\begin{equation}
\begin{cases}
\ket{0} \rightarrow \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \\
\ket{1} \rightarrow \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})
\end{cases}
\end{equation}
Una propiedad que cumple $H^2 = I$ que se comprueba fácilmente. Esto nos permite posteriormente llevar estados $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ a $\ket{0}$, lo que usaremos posteriormente en los algoritmos.

Ya hemos mencionado que es posible visualizar las puertas cuánticas como rotaciones en la esfera de Bloch, por ejemplo si tomamos la expresión de un estado de un qubit en polares,
\begin{equation}
\ket{\psi} = \cos(\theta)\ket{0} + e^{i\varphi}\sin(\theta)\ket{1},
\end{equation}
y le aplicamos la siguiente matriz
\begin{equation}
R(\omega) = \begin{bmatrix}
	1 & 0 \\
	0 & e^\omega
\end{bmatrix} 
\end{equation}
obteniendo como resultado:
\begin{equation}
\ket{\psi'} = \cos(\theta)\ket{0} + e^\omega e^{i\varphi}\sin(\theta)\ket{1} = \cos(\theta)\ket{0} + e^{i\varphi + \omega}\sin(\theta)\ket{1}
\end{equation}
de esta manera hemos conseguido rotar la esfera alrededor del eje Z, por lo que no hemos variado lo que podemos considerar como latitud, sino hemos variado su longitud. Este tipo de operaciones se denominan \textbf{cambios de fase}, ya que sólo estamos alterando el valor del parámetro $e^{i\varphi}$, que denominaremos como \textbf{fase}. Observamos que esta alteración de la fase del estado del qubit no produce cambios en cuanto a la medición del mismo, ya que la probabilidad de que un qubit colapse en un estado clásico depende en este caso únicamente del parámetro $\theta$, su latitud en la esfera de Bloch, o también \textbf{amplitud}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=.65]{rotacion_fase}
	\caption{Fuente: Yanofsky \cite{yanofsky2008quantum}}
\end{figure}

Otras rotaciones, por ejemplos si queremos rotar la espera un cierto ángulo $\omega$ respecto a un eje, tendría la siguiente expresión:
\begin{equation}
\begin{cases}
R_x(\omega) = \cos(\frac{\omega}{2})I -i\sin(\frac{\omega}{2})X =
\begin{bmatrix}
cos(\frac{\omega}{2}) & -i\sin(\frac{\omega}{2}) \\
-i\sin(\frac{\omega}{2}) & \cos(\frac{\omega}{2})
\end{bmatrix} \\
R_y(\omega) = \cos(\frac{\omega}{2})I -i\sin(\frac{\omega}{2})Y =
\begin{bmatrix}
	cos(\frac{\omega}{2}) & -\sin(\frac{\omega}{2}) \\
	\sin(\frac{\omega}{2}) & \cos(\frac{\omega}{2})
\end{bmatrix} \\
R_z(\omega) = \cos(\frac{\omega}{2})I -i\sin(\frac{\omega}{2})Z =
\begin{bmatrix}
	e^{-i\omega/2} & 0 \\
	0 & e^{i\omega/2}
\end{bmatrix}
\end{cases}
\end{equation}
También podemos realizar rotaciones respecto de un vector dado, consideramos $D = (D_x, D_y, D_z)$ un vector arbitrario de módulo 1, con las coordenadas correspondientes. La matriz de la rotación estará determinada por la siguiente expresión:
\begin{equation}
R_D(\omega) = \cos(\frac{\omega}{2})I -i\sin(\frac{\omega}{2})(D_x X + D_y Y + D_z Z)
\end{equation}
Veamos ahora, puertas cuánticas que involucren más de un qubit, que a pesar de que no podremos representarlos ya en la esfera de Bloch, podemos seguir considerando su representación matricial.

Una de las puertas más importantes es la puerta \textbf{NOT controlada} o \textbf{CNOT}. Esta puerta tomará dos entradas y dará dos salidas. La primera entrada la llamaremos bit de control, es decir, controlará el bit de salida. Representaremos la puerta en la siguiente ilustración de un circuito cuántico, donde cada recta horizontal representa un cable que lleva el qubit siguiendo la lectura de izquierda a derecha.
\begin{figure}[h]
\centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \lstick{\ket{x}} & \ctrl{1} & \qw & \rstick{\ket{x}}\\
	 \lstick{\ket{y}} & \targ & \qw  & \rstick{\ket{x\oplus y}}\\
\\ }}
\end{figure}
Si $\ket{x} = \ket{0}$, la salida del segundo bit $\ket{y}$ permanecerá igual. Si  $\ket{x} = \ket{1}$ entonces $\ket{y}$ se le aplicará la puerta NOT, es decir, será lo opuesto. Es decir, realiza la siguiente transformación
\begin{equation}
\begin{cases}
\ket{00} \rightarrow \ket{00} \\
\ket{01} \rightarrow \ket{01} \\
\ket{10} \rightarrow \ket{11} \\
\ket{11} \rightarrow \ket{10}
\end{cases}
\end{equation}
Esto se puede ver como que la puerta transforma un par de bits $\ket{x, y}$ en $\ket{x, x\oplus y}$, donde $\oplus$ es la operación binaria de OR excluyente, o también como la suma en módulo 2.
También podemos describir la puerta CNOT con su representación matricial, considerando como base del espacio vectorial $\lbrace \ket{00}, \ket{01}, \ket{10}, \ket{11} \rbrace$,
\begin{equation}
\textrm{CNOT} = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 
\end{bmatrix}
\end{equation}
Observamos que claramente esta puerta es unitaria pues el producto por su adjunta que es ella misma resulta en la matriz identidad, pues tenemos que se cumple que $CNOT^{\dagger} CNOT = I$.
Esto también se puede entender como que la puerta CNOT es reversible por ella misma:\\
\begin{figure}[h]
\centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	\nghost{0} & \ket{x} & \ & \ & \ & \ & \ket{x} & \ & \ & \ & \ket{x}  \\
	\nghost{1} & \qw & \qw & \qw & \ctrl{2} & \qw & \qw & \qw & \ctrl{2} & \qw & \qw & \qw \\
	\nghost{2} & \ket{y} & \ & \ & \ & \ & \ket{x\oplus y} & \ & \ & \ & \ & \ & \ket{x\oplus(x\oplus y)}  \\
	\nghost{3} & \qw & \qw & \qw & \targ & \qw & \qw & \qw & \targ & \qw & \qw & \qw \\
\\ }}
\end{figure}

El estado de entrada es $\ket{x, y}$ que queda trasformado en $\ket{x, x\oplus y}$ y esta última en $\ket{x, x\oplus (x\oplus y)}$. Esto es $\ket{x, (x\oplus x) \oplus y} = \ket{x, 0\oplus y} = \ket{x, y}$, ya que $x\oplus x = 0$.\\
\linebreak
Otra puerta reversible de mucha importancia es la de \textbf{Toffoli},
que funciona de manera similar a la puerta NOT controlada. Trabaja con 3 bits de entrada y salida, en el que aplica la puerta NOT al último bit $\ket{z}$ si y solo si los dos anteriores tienen por estado 1, $\ket{x, y} = \ket{11}$. En otras palabras lleva el $\ket{x,y,z}$ a $\ket{x,y,z\oplus(x\wedge y)}$. \\
\begin{figure}[h]
\centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \lstick{\ket{x}} & \ctrl{1} & \qw & \rstick{\ket{x}}\\
	 \lstick{\ket{y}} & \ctrl{1} & \qw & \rstick{\ket{y}}\\
	 \lstick{\ket{z}} & \targ & \qw  & \rstick{\ket{z\oplus(x\wedge y)}}\\
\\ }}
\end{figure}

Esta puerta tiene por matriz:
\begin{equation}
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}
\end{equation}
Ya hemos visto varias puertas que son reversibles, ahora, llamaremos puertas cuánticas a aquellas aplicaciones que actúan sobre qubits, como vectores de un espacio vectorial complejo y tendrá como representación matricial, matrices unitarias.\\

Una excepción de las puertas cuánticas sería la operación de medir un qubit, que se suelen realizar al final del circuito y que no son reversibles. Representaremos estas de la siguiente manera en el circuito, donde la doble recta horizontal, representa un cable que lleva información clásica, un bit.
\begin{figure}[h]
\centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \nghost{cw} & \lstick{\ket{\psi}} & \qw & \meter & \cw & \cw\\
\\ }}
\end{figure}\\
Hemos visto varios ejemplos de circuitos cuánticos con las puertas cuánticas. Vamos a centrarnos en construir circuitos más complejos combinando las puertas. Podemos tanto concatenar las puertas, realizando una operación tras otra, y operar de manera paralela con ellas, de manera simultanea a un subconjunto del sistema de qubits. Hacemos notar varias restricciones respecto al mundo clásico y es que no permitiremos bucles en los circuitos, de manera que cada circuito funcione de izquierda a derecha y sea acíclico. Además no permitiremos tanto combinar dos cableado en uno, como dividir uno en dos. Veremos en un ejemplo próximo que de hecho no podemos copiar el estado de un qubit a otro.\\
\linebreak
En cuanto a concatenar las puertas en un circuito, simplemente realizaremos una operación tras otra, de manera ordenada. Si queremos tratar la operación como una matriz, esta se representará por productos de matrices de manera natural. Por ejemplo si queremos aplicar dos veces la puerta CNOT como hemos hecho antes,
\begin{equation}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 
\end{bmatrix} = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 
\end{bmatrix}
\end{equation}
resultando lo que esperábamos, ya que la puerta CNOT es reversible por sí misma, resultando que la concatenación de ella con sigo misma es la identidad.\\
\linebreak
También podemos realizar operaciones de manera paralela a distintos bits a través de productos tensoriales entre las matrices, siempre cuidando el tamaño de las matrices. Por ejemplo, si queremos aplicar la puerta de Hadamard $H$ a ambos qubits de un sistema de dos qubits, el resultado final será igual que aplicar $(H\otimes H)$ como una puerta al sistema,
\begin{figure}[h]
\centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \lstick{\ket{x}} & \gate{\mathrm{H}} & \qw \\
	 \lstick{\ket{y}} & \gate{\mathrm{H}} & \qw \\
\\ }}
\end{figure}
Recordemos la propiedad del producto tensorial sobre las aplicaciones con la expresión \ref{prtensorial_aplineal}, de esta manera tenemos que,
\begin{equation} \label{matriz_tensorial}
(H\ket{x})\otimes(H\ket{y}) = (H\otimes H)\ket{x\otimes y}
\end{equation}
Vamos a ver un ejemplo más de circuito en el que concatenemos la puerta CNOT con la puerta de Hadamard. Consideramos entonces el circuito:
\begin{figure}[h]
\centering
\scalebox{1.0}{
\Qcircuit @C=1.0em @R=0.2em @!R { \\
	 	\lstick{\ket{x}} & \gate{\mathrm{H}} & \ctrl{1} & \qw & \qw\\
	 	\lstick{\ket{y}} & \qw & \targ & \qw & \qw &\ustick{\ket{\psi'}}\\
\\ }}
\end{figure}\\
Supongamos entonces que comenzaremos con el estado $\ket{00}$, para los otros casos el procedimiento es análogo. Entonces tendríamos que operar la siguiente expresión:
\begin{equation}
\ket{\psi'} = \textrm{CNOT}\cdot(H\otimes I)(\ket{x\otimes y})
\end{equation}
Hacemos notar que a pesar de que no le aplicamos ninguna puerta de manera simultanea a $\ket{y}$ para poder hacer el producto de matrices adecuadamente, es necesario aplicar el producto tensorial a la puerta de Hadamard con la identidad, que no altera el estado de $\ket{y}$.\\
Resolvamos entonces la expresión, con el estado $\ket{00}$ en concreto. Aplicando la propiedad de la expresión \ref{matriz_tensorial} , tenemos que:
\begin{equation}
\ket{\psi'} = \textrm{CNOT}\cdot(H\otimes I)(\ket{00}) = \textrm{CNOT}((H\ket{0}) \otimes (I\ket{0})) = \textrm{CNOT}(\frac{\ket{0}+\ket{1}}{\sqrt{2}}\otimes\ket{0})
\end{equation}
Reordenando la expresión con las propiedades del producto escalar tenemos que:
\begin{equation}
\ket{\psi'} = \textrm{CNOT}(\frac{1}{\sqrt{2}}(\ket{00} + \ket{10}))
\end{equation}
y finamente, aplicando la linealidad de CNOT:
\begin{equation}
\ket{\psi'} = \frac{1}{\sqrt{2}}(\textrm{CNOT}\ket{00} + \textrm{CNOT}\ket{10}) = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11})
\end{equation}
Si recordamos de la sección anterior, hemos producido con este circuito empezando en el estado $\ket{00}$ al estado de Bell que hemos visto.\\
Este desarrollo de naturaleza algebraica que hemos hecho, tiene su equivalente en operaciones matriciales, pues podríamos haber hecho el producto de las matrices:
\begin{equation}
\textrm{CNOT}\cdot(H\otimes I) = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 
\end{bmatrix} \cdot \left( \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1 
\end{bmatrix} \otimes
\begin{bmatrix}
1 & 0 \\
0 & 1 
\end{bmatrix}\right)
\end{equation}
Si operamos, obtendremos la siguiente matriz:
\begin{equation}
\frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
1 & 0 & -1 & 0 \\
0 & 1 & 0 & -1 
\end{bmatrix} =
\frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
0 & 1 & 0 & -1 \\
1 & 0 & -1 & 0
\end{bmatrix}
\end{equation}
Por tanto si operamos con $\ket{00}$, tendremos:
\begin{equation}
\frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
0 & 1 & 0 & -1 \\
1 & 0 & -1 & 0
\end{bmatrix}
\begin{bmatrix}
1 \\ 0 \\ 0 \\ 0
\end{bmatrix} = 
\frac{1}{\sqrt{2}}
\begin{bmatrix}
1 \\ 0 \\ 0 \\ 1
\end{bmatrix}
\end{equation}
que es la expresión matricial del estado de Bell
\begin{equation}
\frac{\ket{00} + \ket{11}}{\sqrt{2}}
\end{equation}
\newpage

\section{Algoritmos Cuánticos}

En general, los algoritmos cuánticos siguen un esquema común entre ellos. Estos consistirán en:
\begin{itemize}
\item Comenzaremos con una serie de qubits en su estado clásico, es decir, $\ket{0}$ ó $\ket{1}$
\item Luego, serán puestos en superposición de varios estados.
\item Se le aplicarán una serie de operaciones unitarias a través de puertas cuánticas.
\item Y finalmente se medirán los qubits correspondientes y según el algoritmo, se repetirá este proceso varias veces y se compararán los resultados.

\end{itemize}

Vamos ahora a estudiar más en profundidad unos algoritmos en concreto e implementaremos algunos de ellos en qiskit. Estos ficheros se encuentran en la carpeta \textit{./qiskit/} del repositorio. Concretamente implantaremos los siguientes algoritmos:
\begin{itemize}
\item Algoritmo de Deutsch.(\textit{./qiskit/test\_deutsch.ipynb})

\item Algoritmo de Deutsch-Jozsa.(\textit{./qiskit/test\_deutsch\_jozsa.ipynb})

\item Algoritmo de Grover.(\textit{./qiskit/test\_grover.ipynb})

\item Algoritmo de Simon.(\textit{./qiskit/test\_simon.ipynb})
\end{itemize}
Recordemos que con todos los algoritmos hemos ejecutado una simulación en un ordenador clásico. A excepción del algoritmo de Deutsch-Jozsa y el algoritmo de Grover que lo hemos ejecutado en un ordenador cuántico real.


\subsection{Algoritmo de Teletransportación}
Empezaremos viendo un algoritmo sencillo que lo único que hará será teletransportar o mover un qubit en un estado arbitrario $\ket{\varphi}$ de un sitio a otro. Esta operación nos presenta los problemas más típicos del mundo cuántico, y es que no conocemos el estado $\ket{\varphi}$ en el que se encuentra el qubit, es decir, los valores de $\alpha$ y $\beta$ de $\ket{\varphi} = \alpha\ket{0} + \beta\ket{1}$. Además de que no podemos determinar sus valores con sólo una copia del qubit, y que sólo sabemos enviar información de manera clásica en forma de bits.\\

El algoritmo toma ventaja del enlazamiento entre qubits para superar los problemas. Consideramos un transmisor y un receptor, además de un par de qubits que se encuentra en el estado de Bell. Nuestro transmisor tiene el control de uno de los qubits, mientras que el receptor tiene el control del otro. El algoritmo consistirá entonces en el transmisor interactua con el qubit $\ket{\varphi}$ y su correspondiente qubit del par en estado de Bell, seguido de tomar mediciones de los dos qubits y enviar la información de los bits resultantes al receptor. Este último aplicará ciertas operaciones dependiendo de la información recibida a su qubit del par en estado de Bell, resultado en el qubit $\ket{\varphi}$.\\
Veamos esto en el circuito y revisemos las cuentas paso a paso. Consideramos el estado inicial de entrada $\ket{\varphi_0} = \ket{\varphi}\ket{\beta_{00}}$ que es un sistema de tres qubits formados por el qubit $\ket{\varphi}$ y un par de qubits en estado de Bell.

\begin{figure}[h]
\centering
\scalebox{1.5}{
\Qcircuit @C=1.0em @R=0.2em @!R { \\
	 	\rstick{\ket{\varphi}} & \nghost{} & \ctrl{1} & \gate{\mathrm{H}} & \meter & \cw & \controlo \cw_(0.4){\mathrm{M_1}} \cwx[2] \\
	 	\dstick{\ket{\beta_{00}}} & \nghost{} & \targ & \qw & \meter & \controlo \cw_(0.4){\mathrm{M_2}} \cwx[1]  \\
	 	\nghost{} & \nghost{} & \qw^(0.5){\ket{\varphi_0}} & \qw^(0.5){\ket{\varphi_1}} & \qw^(0.5){\ket{\varphi_2}} & \gate{\mathrm{Z^{M_2}}} & \gate{\mathrm{X^{M_1}}} & \qw &\rstick{\ket{\varphi}}\\}}
\end{figure}\ \linebreak
Ponemos el estado inicial en la expresión que nos conviene usando la propiedad distributiva respecto de la suma.
\begin{equation}
\begin{split}
\ket{\varphi_0} & =
 \ket{\varphi}\ket{\beta_{00}} =
\left[\alpha\ket{0} + \beta\ket{1}\right] \otimes \left[ \frac{\ket{00} + \ket{11}}{\sqrt{2}} \right] \\
& =
\frac{1}{\sqrt{2}} \left[ \alpha\ket{0}(\ket{00}+\ket{11}) + \beta\ket{1}(\ket{00}+\ket{11}) \right]
\end{split}
\end{equation}
Aplicamos la puerta CNOT a los dos primeros qubits, recordemos que la puerta CNOT cambia el estado del segundo qubit si el primero es un $1$, mientras que si el primer qubit es un $0$ dejará igual el sgundo qubit. Aprovechando entonces la linealidad de CNOT, tenemos por resultado
\begin{equation}
\ket{\varphi_1} = 
\frac{1}{\sqrt{2}} \left[ \alpha\ket{0}(\ket{00}+\ket{11}) + \beta\ket{1}(\ket{10}+\ket{01}) \right]
\end{equation}
Aplicamos entonces la puerta de Hadamard en el primer qubit, obteniendo
\begin{equation}
\ket{\varphi_2} = 
\frac{1}{\sqrt{2}} \left[ \alpha \left( \frac{\ket{0}+\ket{1}}{\sqrt{2}} \right) (\ket{00}+\ket{11}) + \beta\left( \frac{\ket{0}-\ket{1}}{\sqrt{2}} \right)(\ket{10}+\ket{01}) \right]
\end{equation}
Reordenamos la expresión
\begin{equation}
\begin{split}
\ket{\varphi_2} = 
\frac{1}{2} \left[ \alpha\left(\ket{000} + \ket{011} + \ket{100} + \ket{111}\right) + \beta\left(\ket{010} + \ket{001} - \ket{110} - \ket{101}\right) \right] = 
\\
\frac{1}{2} \left[ \ket{00}(\alpha\ket{0}+\beta\ket{1}) + \ket{01}(\alpha\ket{1}+\beta\ket{0}) + \ket{10}(\alpha\ket{0}-\beta\ket{1} + \ket{11}(\alpha\ket{1}-\beta\ket{0})) \right]
\end{split}
\end{equation}
Realizamos entonces la medición de los dos primeros qubits, que por estar enlazados los qubits, el resultado también determinará el estado del tercer qubit.
\begin{equation}
\begin{array}{l}
00 \longrightarrow \alpha\ket{0}+\beta\ket{1} \\
01 \longrightarrow \alpha\ket{1}+\beta\ket{0} \\
10 \longrightarrow \alpha\ket{0}-\beta\ket{1} \\
11 \longrightarrow \alpha\ket{1}-\beta\ket{0}
\end{array}
\end{equation}
Quedará finalmente realizar la transformación correspondiente al tercer qubit. Si el resultado de la medición es $00$ entonces no es necesario realizar ningún cambio pues tenemos que el estado del tercer qubit es $\alpha\ket{0}+\beta\ket{1} = \ket{\varphi}$. Si es $01$ tendremos que aplicar la puerta $X$ para transformar el $1$ en $0$ y el $0$ en $1$. Si es $10$ aplicaremos entonces la puerta $Z$ que cambia el signo de la segunda coordenada, el coeficiente de $\ket{1}$. Y finalmente, en el caso de $11$ aplicaremos primero la puerta $X$, seguido de la puerta $Z$.
Esto sería equivalente a aplicar la transformación $Z^{M_1} X^{M_2}$ con $M_1$ y $M_2$ el valor de los dos primeros qubits, recuperando entonces el estado $\ket{\varphi}$ en el qubit que controla el receptor.\\

Hacemos notar que hemos llevado el estado $\ket{\varphi}$ de un qubit a otro, pero no lo hemos copiado, pues el estado del primer qubit ha sido sobreescrito con las operaciones realizadas.
Como hemos mencionado antes, el proceso de copiar el estado de un qubit a otro no es posible. Podemos ver esto en que entra en contradicción con la propiedad lineal de las aplicaciones.\\ Suponemos $C$ una aplicación correspondiente a la operación cuántica de copiar el estado de un qubit a otro. La hacemos actuar sobre un par de qubits resultando en
\begin{equation}
C\left(\frac{\ket{x}+\ket{y}}{\sqrt{2}} \otimes \ket{0}\right) = 
\left(\frac{\ket{x}+\ket{y}}{\sqrt{2}} \otimes \frac{\ket{x}+\ket{y}}{\sqrt{2}}\right)
\end{equation}
Sin embargo, si aplicamos la propiedad lineal de $C$, tenemos que
\begin{equation}
\begin{split}
C\left(\frac{\ket{x}+\ket{y}}{\sqrt{2}} \otimes \ket{0}\right) 
&=
\frac{1}{\sqrt{2}}C\left((\ket{x}+\ket{y}) \otimes \ket{0}\right)
=
\frac{1}{\sqrt{2}} C(\ket{x}\otimes\ket{0} + \ket{y}\otimes\ket{0})
\\&=
\frac{1}{\sqrt{2}} C(\ket{x}\otimes\ket{0}) + C(\ket{y}\otimes\ket{0})
=
\frac{1}{\sqrt{2}} (\ket{x}\otimes\ket{x}) + (\ket{y}\otimes\ket{y})
\\&=
\frac{(\ket{x}\otimes\ket{x}) + (\ket{y}\otimes\ket{y})}{\sqrt{2}}
\end{split}
\end{equation}
Que claramente llegamos a resultados distintos, concluyendo en que hemos encontrado una contradicción. Por tanto la aplicación $C$ no es lineal y no se puede copiar estados de qubits.

\subsection{Algoritmo de Deutsch}

Veamos ahora un algoritmo simple que llamaremos como el algoritmo de Deutsch. Este algoritmo tratará de ver si se cumple cierta propiedad para una función $f:\{0, 1\} \rightarrow \{0, 1\}$, concretamente si es balanceada o constante.

\begin{deff}
Diremos que la función $f:\{0, 1\} \rightarrow \{0, 1\}$ es balanceada si $f(0) \neq f(1)$, y diremos que es constante si $f(0) = f(1)$.
\end{deff}
El algoritmo consistirá en tomar una función $f:\{0, 1\} \rightarrow \{0, 1\}$, que desconocemos su definición y sólo podremos evaluarla obteniendo su imagen con el objetivo de determinar si la función es balanceada o constante.\\
En un algoritmo clásico podríamos siempre evaluar la función en todos sus valores para determinar si es balanceada o constate. Esto nos llevaría un total de dos evaluaciones de la función. Veamos si el algoritmo cuántico puede mejorar esto ya que nos permite evaluar de manera simultanea sobre todos los valores posibles.\\
Para ello tomaremos una puerta cuántica que evaluará la función y observamos que esta tiene que ser reversible. Consideraremos la siguiente operación unitaria $U_f$. A esta función a veces nos referiremos como oráculo, ya que nos evaluará la función indicando la imagen sin que nosotros sepamos la definición de la función. Recordemos también está representado por una matriz unitaria.
\begin{figure}[h]
\centering
\scalebox{1.5}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \lstick{\ket{x}} & \multigate{1}{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} & \qw & \rstick{\ket{x}} \\
	 \lstick{\ket{y}} & \nghost{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} \qw & \qw &  \rstick{\ket{y\oplus f(x)}}\\
\\ }}
\end{figure}\linebreak
En la primera entrada $\ket{x}$ será lo que queremos evaluar, y en la segunda entrada $\ket{y}$ actuará como un qubit de control. Tras el cuál, en la primera salida $\ket{x}$ permanecerá igual y en la segunda salida tendremos $\ket{y\oplus f(x)}$.\\
Observamos que esta puerta cuántica es reversible pues:

\begin{figure}[h]
\centering
\scalebox{1.5}{
\Qcircuit @C=1.0em @R=0.8em @!R {
	 \nghost{\ket{x}} & \qw_(0.0){\ket{x}} & \multigate{1}{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} & \qw_(-0.4){\ket{x}} & \qw & \qw & \multigate{1}{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} & \qw & \qw_(1.0){\ket{x}}  \\
	 \nghost{\ket{y}} & \qw_(0.0){\ket{y}} & \nghost{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} \qw & \qw & \qw_(0.0){\ket{y\oplus f(x)}} & \qw & \nghost{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} \qw & \qw_(-1.2){\ket{(y\oplus f(x))\oplus f(x)}} & \qw \\}}
\end{figure}\ \linebreak
El estado $\ket{x, y}$ queda trasformado en $\ket{x, y\oplus f(x)}$ y posteriormente en \\
$\ket{x, (y\oplus f(x))\oplus f(x)} = \ket{x, y\oplus (f(x)\oplus f(x))} = \ket{x, y\oplus 0} = \ket{x, y}$, ya que $f(x)\oplus f(x) = 0$.\\
Una vez conseguido el oráculo que nos evaluará la función en los qubits, podemos construir el circuito del algoritmo que consistirá en lo siguiente:

\begin{figure}[h]
\centering
\scalebox{1.5}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \nghost{\ket{x}} & \qw_(0.0){\ket{0}} & \gate{\mathrm{H}} & \qw & \multigate{1}{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} & \qw & \gate{\mathrm{H}} & \qw & \meter \\
	 \nghost{\ket{y}} & \qw_(0.0){\ket{1}} & \gate{\mathrm{H}} & \qw^(0.0){\ket{\varphi_1}} & \nghost{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} \qw & \qw^(0.0){\ket{\varphi_2}} & \qw & \qw^(0.0){\ket{\varphi_3}} & \qw \\}}
\end{figure}\ \linebreak
Esto en términos matriciales sería:
\begin{equation}
(H\oplus I) U_f (H\oplus H) \ket{0, 1} = 
(H\oplus I) U_f (H\oplus H)
\begin{bmatrix}
0 \\ 1 \\ 0 \\ 0
\end{bmatrix}
\end{equation}
Veamos en detalle el resultado al que se llega. Empezamos con el estado $\ket{\varphi_0} = \ket{0, 1}$ que pondremos en superposición con la puerta de Hadamard.
Hadamard transforma a $\ket{0}$ en $\frac{\ket{0} + \ket{1}}{\sqrt{2}}$ y $\ket{1}$ en $\frac{\ket{0} - \ket{1}}{\sqrt{2}}$, por tanto,
\begin{equation}
\ket{\varphi_1} = \left[ \frac{\ket{0} + \ket{1}}{\sqrt{2}} \right] \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right] =
\frac{\ket{0,0} - \ket{0,1} + \ket{1,0} - \ket{1,1}}{2} = 
\begin{bmatrix}
+\frac{1}{2} \\ -\frac{1}{2} \\ +\frac{1}{2} \\ -\frac{1}{2}
\end{bmatrix}
\end{equation}
Ahora, aplicaremos el oráculo $U_f$ a la expresión $\frac{\ket{0,0} - \ket{0,1} + \ket{1,0} - \ket{1,1}}{2}$ y recordando que $U_f$ no deja de ser una aplicación lineal. Por tanto, tenemos que
\begin{equation}
\ket{\varphi_2} = U_f \frac{\ket{0,0} - \ket{0,1} + \ket{1,0} - \ket{1,1}}{2} = \frac{U_f\ket{0,0} - U_f\ket{0,1} + U_f\ket{1,0} - U_f\ket{1,1}}{2} 
\end{equation}
Recordemos que nuestro oráculo $U_f$ transforma $\ket{x,y}$ en $\ket{x,y\oplus f(x)}$, por lo que
\begin{equation}
\begin{split}
\ket{\varphi_2} =
\frac{\ket{0,0\oplus f(0)} - \ket{0,1\oplus f(0)} + \ket{1, 0\oplus f(1)} - \ket{1, 1\oplus f(1)}}{2} = \\
\frac{\ket{0,f(0)} - \ket{0,\overline{f(0)}} + \ket{1,f(1)} - \ket{1,\overline{f(1)}}}{2}
\end{split}
\end{equation}
donde $\overline{f(x)}$ es el opuesto de $f(x)$.\\
Hacemos ver que $\ket{x,y}$ no es más que una notación de $\ket{x}\otimes\ket{y}$, por tanto aplicando la propiedad distributiva del producto tensorial por la derecha tenemos
\begin{equation} \label{eq45}
\ket{\varphi_2} =
\frac{\ket{0} \otimes \left[ \ket{f(0)} - \ket{\overline{f(0)}} \right] + \ket{1} \otimes \left[ \ket{f(1)} - \ket{\overline{f(1)}} \right]}{2}
\end{equation}
Observemos en un momento la expresión $\ket{f(x)} -\ket{\overline{f(x)}}$ para $x \in \lbrace 0,1 \rbrace$ y discutimos su valor según el valor de $f(x)$.
\begin{equation} \label{eq413}
\ket{f(x)} - \ket{\overline{f(x)}} =
\begin{cases}
\ket{0} - \ket{1} \ \textrm{si} \ f(x) = 0 \\
\ket{1} - \ket{0} \ \textrm{si} \ f(x) = 1
\end{cases} =
\begin{cases}
\ket{0} - \ket{1} \ \textrm{si} \ f(x) = 0 \\
-(\ket{0} - \ket{1}) \ \textrm{si} \ f(x) = 1
\end{cases}
\end{equation}
que escribiremos como $(-1)^{f(x)}(\ket{0} - \ket{1})$.\\
Aplicando esto a la expresión \ref{eq45} tenemos que
\begin{equation}
\ket{\varphi_2} = 
\frac{(-1)^{f(0)} (\ket{0} \otimes \left[ \ket{0} - \ket{1} \right]) + (-1)^{f(1)} (\ket{1} \otimes \left[ \ket{0} - \ket{1} \right])}{2}
\end{equation}
Hacemos uso de la propiedad distributiva por la derecha y reordenamos los escalares para separar la expresión en producto escalar de dos términos
\begin{equation}
\ket{\varphi_2} =
\left[ \frac{(-1)^{f(0)} \ket{0} + (-1)^{f(1)} \ket{1}}{\sqrt{2}} \right]
\left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\end{equation}
Discutamos el valor de la expresión $(-1)^{f(0)} \ket{0} + (-1)^{f(1)} \ket{1}$ según si $f(x)$ es constante o balanceada.
\begin{equation}
\ket{\varphi_2} = 
\begin{cases}
(\pm 1) \left[\frac{\ket{0}+\ket{1}}{2}\right] \left[\frac{\ket{0}-\ket{1}}{2}\right] & \textrm{si } f \textrm{ es constante,} \\
(\pm 1) \left[\frac{\ket{0}-\ket{1}}{2}\right] \left[\frac{\ket{0}-\ket{1}}{2}\right] & \textrm{si } f \textrm{ es balanceada.}
\end{cases}
\end{equation}
Teniendo en cuenta que Hadamard es su propia inversa, llevará $\frac{\ket{0}+\ket{1}}{2}$ a $\ket{0}$ y $\frac{\ket{0}-\ket{1}}{2}$ a $\ket{1}$.
\begin{equation}
\ket{\varphi_3} = 
\begin{cases}
(\pm 1) \ket{0} \left[\frac{\ket{0}-\ket{1}}{2}\right] & \textrm{si } f \textrm{ es constante,} \\
(\pm 1) \ket{1} \left[\frac{\ket{0}-\ket{1}}{2}\right] & \textrm{si } f \textrm{ es balanceada.}
\end{cases}
\end{equation}
Finalmente medimos el qubit superior para determinar si f es constante o balanceada, ya que si sale $\ket{0}$ será constante y si sale $\ket{1}$ será balanceada. Observamos que el signo no afecta a la proceso de medir, pues recordemos que la probabilidad de que sea un estado depende de la norma al cuadrado.\\
Observamos que hemos conseguido en una evaluación de la función determinar si la propiedad de ser balanceada o constante. Sin embargo hacemos notar que para determinar cuál de los cuatro posibles funciones es, necesitamos evaluar de nuevo la función con este algoritmo.

\newpage

\subsection{Algoritmo de Deutsch-Jozsa}
Veremos ahora el mismo problema pero generalizando la función. Consideramos ahora la función $f:\{0, 1\}^n \longrightarrow \{0, 1\}$ que lleva cadenas de $n$ $0$ y $1$ a un único $0$ ó $1$ como imagen.\\
\begin{deff}
Diremos entonces que $f:\{0, 1\}^n \longrightarrow \{0, 1\}$ es balanceada si exactamente la mitad de los elementos del dominio de la función tiene a $0$ por imagen, y la otra mitad a $1$. Diremos también que la función es constante si todos los elementos tiene como imagen el $0$ ó si todos los elementos tiene como imagen el $1$.
\end{deff}
El algoritmo de Deutsch-Jozsa resuelve el problema de dada una función $f:\{0, 1\}^n \longrightarrow \{0, 1\}$ con la que podemos evaluar pero no sabemos cómo está definido, suponiendo que la función sólo puede ser balanceada o constante, tenemos que determinar cuál de estas dos propiedades cumple.\\

Veamos primero como se podría resolver utilizando un método clásico. Se podría evaluar la función diferentes valores para poder determinar si es balanceada o constante. En el mejor de los casos, si tras dos evaluaciones se llega a dos imágenes distintas, podemos concluir que es balanceada pues está asegurado que cumpla una de las propiedades. En el peor de los casos se requiere evaluar la mitad de los elementos más uno, si todas las imágenes comprobadas son iguales se llega a que la función es constante, en otro caso será balanceada. Esto requiere en el pero de los casos $\frac{2^n}{2}+1$ evaluaciones de la función, veamos si con el algoritmo cuántico se puede mejorar.\\
\linebreak
El algoritmo consistirá como el anterior, pondremos los qubits en estado de superposición para poder evaluarlos de manera simultanea en el oráculo. Este tendrá la siguiente forma, que se podrá representar con una matriz unitaria.\\
\begin{figure}[h]
\centering
\scalebox{1.5}{
\Qcircuit @C=1.0em @R=0.8em @!R {
	 \lstick{\ket{\mathbf{x}}} & \qw & \lstick{/^{n}} \qw & \multigate{1}{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} & \qw & \lstick{/^{n}} \qw & \rstick{\ket{\mathbf{x}}} \\
	 \lstick{\ket{y}} & \qw & \qw & \nghost{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} \qw & \qw & \qw & \rstick{\ket{y\oplus f(\mathbf{x})}}
	 \\}}
\end{figure}\linebreak
donde \Qcircuit @C=1.0em @R=0.8em @!R {\nghost{} & \qw & \lstick{/^{n}} \qw & \nghost{}} indica que hay $n$ qubits y usaremos $\ket{\mathbf{x}} = \ket{x_0 x_1\dots x_{n-1}}$ para denotar la cadena binaria. En este caso, $\ket{\mathbf{x}}$ quedará igual tras el oráculo $U_f$, mientras que $\ket{y}$ será el qubit de control. Es fácil ver que, como en el algoritmo anterior, el oráculo $U_f$ es reversible por sí misma.\\

Una vez obtenido el oráculo, queremos poner en superposición los $n$ qubits. Para ello usaremos la matriz de Hadamard, concretamente el producto tensorial de $n$ matrices de Hadamard. Veamos primero qué forma tiene esta matriz. Recordemos que la matriz de Hadamard tiene esta forma:
\begin{equation}
H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix}
\end{equation}\linebreak
Observamos que el elemento de la fila $i$ columna $j$ se puede expresar como $H[i, j] = \frac{1}{\sqrt{2}}(-1)^{i\wedge j}$, con $i$ y $j$ expresado en binario y $\wedge$ es la operación AND. De esta manera, la matriz de queda escrito como:
\begin{equation}
H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
(-1)^{0\wedge 0} & (-1)^{0\wedge 1} \\
(-1)^{1\wedge 0} & (-1)^{1\wedge 1}
\end{bmatrix}
\end{equation}
Calculemos ahora el producto tensorial de dos matrices de Hadamard, que lo podemos expresar en forma de potencias de matrices con el producto tensorial que denotaremos como
\begin{equation}
H^{\otimes 2} = H\otimes H =
\frac{1}{\sqrt{2}}
\begin{bmatrix}
(-1)^{0\wedge 0} & (-1)^{0\wedge 1} \\
(-1)^{1\wedge 0} & (-1)^{1\wedge 1}
\end{bmatrix}\otimes
\frac{1}{\sqrt{2}}
\begin{bmatrix}
(-1)^{0\wedge 0} & (-1)^{0\wedge 1} \\
(-1)^{1\wedge 0} & (-1)^{1\wedge 1}
\end{bmatrix}
\end{equation}
\newpage
\begin{equation}
H^{\otimes 2} =
\frac{1}{\sqrt{2}} \cdot \frac{1}{\sqrt{2}}
\begin{bmatrix}
(-1)^{0\wedge 0}\cdot(-1)^{0\wedge 0} & (-1)^{0\wedge 0}\cdot(-1)^{0\wedge 1} & (-1)^{0\wedge 1}\cdot(-1)^{0\wedge 0} & (-1)^{0\wedge 1}\cdot(-1)^{0\wedge 1} 
\\
(-1)^{0\wedge 0}\cdot(-1)^{1\wedge 0} & (-1)^{0\wedge 0}\cdot(-1)^{1\wedge 1} & (-1)^{0\wedge 1}\cdot(-1)^{1\wedge 0} & (-1)^{0\wedge 1}\cdot(-1)^{1\wedge 1} 
\\
(-1)^{1\wedge 0}\cdot(-1)^{0\wedge 0} & (-1)^{1\wedge 0}\cdot(-1)^{0\wedge 1} & (-1)^{1\wedge 1}\cdot(-1)^{0\wedge 0} & (-1)^{1\wedge 1}\cdot(-1)^{0\wedge 1} 
\\
(-1)^{1\wedge 0}\cdot(-1)^{1\wedge 0} & (-1)^{1\wedge 0}\cdot(-1)^{1\wedge 1} & (-1)^{1\wedge 1}\cdot(-1)^{1\wedge 0} & (-1)^{1\wedge 1}\cdot(-1)^{1\wedge 1}
\end{bmatrix}
\end{equation}
Teniendo en cuenta que estamos interesados sólo por el signo de $(-1)^x$ que depende de la paridad de $x$, podemos considerar el producto de $(-1)^x\cdot(-1)^y$ como $(-1)^{x\oplus y}$, donde $\oplus$ es la suma módulo $2$. Entonces, la matriz sería
\begin{equation}
\begin{split}
H^{\otimes 2} =
\frac{1}{2}
\begin{bmatrix}
(-1)^{0\wedge 0\oplus 0\wedge 0} & (-1)^{0\wedge 0\oplus 0\wedge 1} & (-1)^{0\wedge 1\oplus 0\wedge 0} & (-1)^{0\wedge 1\oplus 0\wedge 1} 
\\
(-1)^{0\wedge 0\oplus 1\wedge 0} & (-1)^{0\wedge 0\oplus 1\wedge 1} & (-1)^{0\wedge 1\oplus 1\wedge 0} & (-1)^{0\wedge 1\oplus 1\wedge 1} 
\\
(-1)^{1\wedge 0\oplus 0\wedge 0} & (-1)^{1\wedge 0\oplus 0\wedge 1} & (-1)^{1\wedge 1\oplus 0\wedge 0} & (-1)^{1\wedge 1\oplus 0\wedge 1} 
\\
(-1)^{1\wedge 0\oplus 1\wedge 0} & (-1)^{1\wedge 0\oplus 1\wedge 1} & (-1)^{1\wedge 1\oplus 1\wedge 0} & (-1)^{1\wedge 1\oplus 1\wedge 1}
\end{bmatrix}
\\=
\frac{1}{2}
\begin{bmatrix}
1 & 1 & 1 & 1 \\
1 & -1 & 1 & -1 \\
1 & 1 & -1 & -1 \\
1 & -1 & -1 & 1
\end{bmatrix}
\end{split}
\end{equation}
De esta manera si definimos la aplicación $\langle \ , \ \rangle : \{0, 1\}^n \times \{0, 1\}^n \longrightarrow \{0, 1\}$ de manera que dados dos cadenas binarias de longitud $n$, $\mathbf{x} = x_0 x_1\ldots x_{n-1}$ y $\mathbf{y} = y_0 y_1\ldots y_{n-1}$, se define
\begin{equation}
\begin{split}
\langle \mathbf{x}, \mathbf{y} \rangle &= \langle x_0 x_1\ldots x_{n-1}, y_0 y_1\ldots y_{n-1} \rangle \\&= (x_0 \wedge y_0) \oplus (x_1 \wedge y_1) \oplus \ldots \oplus (x_{n-1} \wedge y_{n-1})
\end{split}
\end{equation}
Observamos que esta aplicación es en realidad el producto escalar del espacio vectorial cuyo cuerpo es el espacio $\mathbb{Z}_2$. Por tanto, podemos expresar $H^{\otimes 2}$ como
\begin{equation}
\begin{bmatrix}
(-1)^{\langle 00, 00 \rangle} & (-1)^{\langle 00, 01 \rangle} & (-1)^{\langle 00, 10 \rangle} & (-1)^{\langle 00, 11 \rangle} 
\\
(-1)^{\langle 01, 00 \rangle} & (-1)^{\langle 01, 01 \rangle} & (-1)^{\langle 01, 10 \rangle} & (-1)^{\langle 01, 11 \rangle} 
\\
(-1)^{\langle 10, 00 \rangle} & (-1)^{\langle 10, 01 \rangle} & (-1)^{\langle 10, 10 \rangle} & (-1)^{\langle 10, 11 \rangle} 
\\
(-1)^{\langle 11, 00 \rangle} & (-1)^{\langle 11, 01 \rangle} & (-1)^{\langle 11, 10 \rangle} & (-1)^{\langle 11, 11 \rangle}
\end{bmatrix}
\end{equation}
Ahora, si queremos generalizarlo para $H^{\otimes n}$ tenemos que su elemento de la fija $i$ columna $j$ expresado los indices en binario, es
\begin{equation}
H^{\otimes n} = \frac{1}{\sqrt{2^n}}(-1)^{\langle i, j \rangle}
\end{equation}
Entonces, si consideramos un estado arbitrario $\ket{\mathbf{y}}$ que estará representado por un vector con un $1$ en la posición $\mathbf{y}$ y el resto $0$ y le aplicamos $H^{\otimes n}$, obtendremos la suma de los elementos de la columna $\mathbf{y}$ de la matriz, es decir,
\begin{equation} \label{gHadamard}
H^{\otimes n}\ket{\mathbf{y}} =
\frac{1}{\sqrt{2^n}}\sum_{\mathbf{x}\in \{ 0, 1\}^n} (-1)^{\langle \mathbf{x}, \mathbf{y} \rangle} \ket{\mathbf{x}}
\end{equation}
Así podremos poner nuestros qubits en un estado de superposición de todos los estados posibles. Por ejemplo podemos tomar el estado $\ket{\mathbf{0}}$ y al aplicarle $H^{\otimes n}$ esta será
\begin{equation} \label{eq427}
H^{\otimes n}\ket{\mathbf{0}} = 
\frac{1}{\sqrt{2^n}}\sum_{\mathbf{x}\in \{ 0, 1\}^n} (-1)^{\langle \mathbf{x}, \mathbf{0} \rangle} \ket{\mathbf{x}} =
\frac{1}{\sqrt{2^n}}\sum_{\mathbf{x}\in \{ 0, 1\}^n} \ket{\mathbf{x}}
\end{equation}
ya que $\langle \mathbf{x}, \mathbf{0} \rangle = 0$, para cualquier valor $\mathbf{x}$.

\newpage

Una vez aclarado esto, podemos proceder a ver el circuito del algoritmo. De manera similar al algoritmo anterior, comenzaremos con $\ket{\mathbf{0}} = \ket{00\ldots 0}$ siendo una cadena de $0$ como el estado de los primeros $n$ qubits, y $\ket{1}$ el qubit de control. Aplicaremos la puerta $H^{\otimes n}$ para poner los primeros $n$ qubits en superposición.

\begin{figure}[h]
\centering
\scalebox{1.5}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \nghost{\ket{x}} & \rstick{/^{n}} \qw_(0.0){\ket{\mathbf{0}}} & \qw & \gate{\mathrm{H}^{\otimes n}} & \qw & \lstick{/^{n}} \qw & \multigate{1}{\hspace{0.3cm}\mathrm{U_f}\hspace{0.3cm}} & \qw & \lstick{/^{n}} \qw & \gate{\mathrm{H^{\otimes n}}} & \qw & \lstick{/^{n}} \qw & \meter \\
	 \nghost{\ket{y}} & \qw_(0.0){\ket{1}} & \qw^(0.0){\ket{\varphi_0}} & \gate{\mathrm{H}} & \qw^(0.0){\ket{\varphi_1}} & \qw & \nghost{\hspace{0.3cm}\mathrm{U_f}\hspace{0.3cm}} \qw & \qw^(0.0){\ket{\varphi_2}} & \qw & \qw & \qw^(0.0){\ket{\varphi_3}} & \qw & \qw \\}}
\end{figure}\ \linebreak
O en término de matrices, esto sería:
\begin{equation}
\left( H^{\otimes n} \otimes I \right) U_f \left( H^{\otimes n} \otimes H \right) \ket{\mathbf{0}, 1}
\end{equation}
Empezamos entonces con el estado $\ket{\varphi_0} = \ket{\mathbf{0}, 1}$ y le aplicamos la matriz de Hadamard, usando la expresión \ref{eq427} y reordenando por la propiedad distributiva
\begin{equation}
\begin{split}
\ket{\varphi_1} &= (H^{\otimes n}\otimes H)\ket{\mathbf{0}, 1} =
\left[H^{\otimes n}\ket{\mathbf{0}} \right] \otimes \left[ H\ket{1} \right] =
\left[ \frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} \ket{\mathbf{x}} \right] \left[ \frac{\ket{0}-\ket{1}}{\sqrt{2}} \right] \\&=
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} \left[ \frac{\ket{\mathbf{x}, 0}-\ket{\mathbf{x}, 1}}{\sqrt{2}} \right]
\end{split}
\end{equation}
Aplicamos $U_f$ recordando que es un aplicación lineal que lleva $\ket{\mathbf{x}, y}$ a $\ket{\mathbf{x}, y\oplus f(\mathbf{x})}$
\begin{equation}
\begin{split}
\ket{\varphi_2} &= U_f
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} \left[ \frac{\ket{\mathbf{x}, 0}-\ket{\mathbf{x}, 1}}{\sqrt{2}} \right]
= 
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} \left[ \frac{U_f\ket{\mathbf{x}, 0} - U_f\ket{\mathbf{x}, 1}}{\sqrt{2}} \right]
\\ &=
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} \left[ \frac{\ket{\mathbf{x}, 0\oplus f(\mathbf{x})} - \ket{\mathbf{x}, 1\oplus f(\mathbf{x})}}{\sqrt{2}} \right] =
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} \ket{\mathbf{x}} \left[ \frac{\ket{f(\mathbf{x})} - \ket{\overline{f(\mathbf{x})}}}{\sqrt{2}} \right]
\end{split}
\end{equation}
donde $\overline{f(\mathbf{x})}$ es el opuesto. Recordemos ahora de expresión \ref{eq413} que podemos poner $\ket{f(\mathbf{x})} - \ket{\overline{f(\mathbf{x})}}$ como $(-1)^{f(\mathbf{x})}(\ket{0} - \ket{1})$, por tanto sustituyendo en la expresión anterior obtenemos
\begin{equation} \label{eq431}
\ket{\varphi_2} =
\left[ \frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})} \ket{\mathbf{x}} \right] \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\end{equation}
Aplicando ahora la matriz $H^{\otimes n}$ a los primeros $n$ qubits, aprovechando la expresión \ref{gHadamard} y que es lineal tenemos que
\begin{equation}
\begin{split}
\ket{\varphi_3} &=
\left[H^{\otimes n}\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})} \ket{\mathbf{x}} \right] \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right] =
\left[\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})} H^{\otimes n}\ket{\mathbf{x}} \right] \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\\&=
\left[\frac{1}{2^n} \sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})} \sum_{\mathbf{z}\in\{ 0, 1\}^n} (-1)^{\langle \mathbf{z}, \mathbf{x} \rangle} \ket{\mathbf{z}} \right] \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\end{split} 
\end{equation}
Ahora juntamos las dos potencias de $(-1)$ teniendo en cuenta que estamos interesados por la paridad del exponente, usamos $\oplus$ la suma módulo $2$.
\begin{equation}
\ket{\varphi_3} =
\left[\frac{ \sum_{\mathbf{x}\in\{ 0, 1\}^n} \sum_{\mathbf{z}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x}) \oplus \langle \mathbf{z}, \mathbf{x} \rangle} \ket{\mathbf{z}} } {2^n} \right] \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\end{equation}
\newpage
Finalmente nos queda medir los $n$ primeros qubits. Nos preguntamos cuál es la probabilidad de que esté en el estado $\ket{\mathbf{0}}$, fijando $\mathbf{z} = \mathbf{0}$. Por tanto, como $\langle \mathbf{z}, \mathbf{x} \rangle = \langle \mathbf{0}, \mathbf{x} \rangle = 0$ para todo $\mathbf{x}$, tenemos que la probabilidad es
\begin{equation}
\left\vert \frac{\sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})}}{2^n} \right\vert^2 
\end{equation}
Observamos que depende únicamente de $f(\mathbf{x})$ por lo que podemos discutir su valor según $f(\mathbf{x})$.\\
Si $f(\mathbf{x})$ es constantemente $0$ ó $1$ tenemos que la probabilidad de estar en el estado $\ket{\mathbf{0}}$ es
\begin{equation}
\left\vert \frac{\sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})}}{2^n} \right\vert^2  =
\left\vert \frac{\sum_{\mathbf{x}\in\{ 0, 1\}^n} (\pm 1)}{2^n} \right\vert^2 =
\left\vert \frac{\pm 2^n}{2^n} \right\vert^2 = 1
\end{equation}
Si $f(\mathbf{x})$ es balanceada, la mitad de los términos $(-1)^{f(\mathbf{x})}$ anulan a la otra mitad y se obtiene que la probabilidad es
\begin{equation}
\left\vert \frac{\sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})}}{2^n} \right\vert^2  =
\left\vert \frac{\sum_{\mathbf{x}\in\{ 0, 1\}^n} 0}{2^n} \right\vert^2 =
\left\vert \frac{0}{2^n} \right\vert^2 = 0
\end{equation}
Podemos concluir que tras la medición, si encontramos el qubit en el estado $\ket{\mathbf{0}}$ la función será constante, mientras que si nos encontramos cualquier otro estado distinto de $\ket{\mathbf{0}}$ la función será balanceada. Esto se debe a que la única manera de que el estado sea $\ket{\mathbf{0}}$ es que la función sea constante.\\
\linebreak
Observamos entonces que el algoritmo cuántico necesita solamente una evaluación de la función, respecto a las $2^{n-1}+1$ del método clásico.

\newpage

\subsection{Algoritmo de Búsqueda de Grover}
Supongamos que tenemos un conjunto de elementos y que queremos buscar aquellos que cumplen cierta propiedad. Un método muy primitivo y poco eficiente sería ir elemento a elemento y comprobar si cumplen esta propiedad. Si consideramos un conjunto de $N$ elementos esto nos llevaría en el peor de los casos $N$ operaciones a realizar, comprobando la propiedad. Estos algoritmos clásicos tiene un orden de complejidad de $O(N)$ pero podemos mejorar esto con el algoritmo de búsqueda de Grover que tiene un orden de complejidad de $O(\sqrt{N})$.\\
\linebreak
Vamos a abordar el problema con funciones. Identificamos los elementos del conjunto con $\mathbf{x} \in \{ 0, 1\}^n$ una cadena binaria. Suponemos por comodidad que $N = 2^n$ y para generalizar el problema suponemos también que hay una cantidad exacta de $M$ elementos que cumple la propiedad que llamaremos soluciones, con $1\leq M \leq N$. A continuación suponemos que tenemos una función $f:\{ 0, 1\}^n \longrightarrow \{ 0, 1\}$ que cumple que
\begin{equation}
f(\mathbf{x}) =
\begin{cases}
1\text{, si } \mathbf{x} \text{ es solución,} \\
0\text{, si } \mathbf{x} \text{ no es solución.}
\end{cases}
\end{equation}
Entonces, nuestro objetivo es buscar aquellas cadenas $\mathbf{x}$ que cumplen que $f(\mathbf{x}) = 1$. Para ello nos apoyaremos en $n$ qubits que pondremos en estado de superposición de todos los estados posibles
\begin{equation}
\ket{\psi} = \frac{1}{\sqrt{N}} \sum_{\mathbf{x}\in\{0,1\}^n} \ket{\mathbf{x}}
\end{equation}
con el propósito de, a través de una serie de operaciones, aumentar la probabilidad de encontrar los qubits en un estado asociado a una solución. Es decir, si consideramos el espacio vectorial con base $\lbrace \ket{\mathbf{x}} \mid \mathbf{x}\in\{0,1\}^n \rbrace$ y $\ket{\psi}$ como vector, se quiere entonces aumentar el valor de aquellas coordenadas del vector correspondientes al elemento de la base que lleve asociado una solución.\\
\linebreak
Veamos antes una interpretación geométrica de estas operaciones. Consideramos primero el vector $\ket{\psi}$ como suma de los vectores de la base y los dividimos en dos partes. Aquellas que son solución y aquellas que no.
\begin{equation}
\ket{\alpha} = \frac{1}{\sqrt{N-M}} \sum_{f(\mathbf{x}) = 0} \ket{\mathbf{x}}
\qquad
\ket{\beta} = \frac{1}{\sqrt{M}} \sum_{f(\mathbf{x}) = 1} \ket{\mathbf{x}}
\end{equation}
Consideramos los vectores que los tienen por suma y lo normalizamos. Podemos ver claramente que se puede expresar $\ket{\psi}$ en función de $\ket{\alpha}$ y $\ket{\beta}$.
\begin{equation}
\ket{\psi} = \sqrt{\frac{N-M}{N}}\ket{\alpha} + \sqrt{\frac{M}{N}}\ket{\beta}
\end{equation}
Entonces podemos poner el vector $\ket{\psi}$ en el espacio bidimensional generado por $\ket{\alpha}$ y $\ket{\beta}$ como se muestra en la figura.

\begin{figure}[!h] \label{figGrover}
\centering
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-0.6,xscale=0.6]
%uncomment if require: \path (0,322); %set diagram left start at 0, and has height of 322

%Shape: Axis 2D [id:dp5288380819499159] 
\draw  (169.2,241.7) -- (410.24,241.7)(192.62,25.6) -- (192.62,264.07) (403.24,236.7) -- (410.24,241.7) -- (403.24,246.7) (187.62,32.6) -- (192.62,25.6) -- (197.62,32.6)  ;
%Straight Lines [id:da8922674117582208] 
\draw    (192.62,241.7) -- (389.82,179.87) ;
\draw [shift={(391.73,179.27)}, rotate = 162.59] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8868994576415257] 
\draw    (192.62,241.7) -- (389.15,302.02) ;
\draw [shift={(391.07,302.61)}, rotate = 197.06] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da5711125744764711] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (391.73,179.27) -- (391.07,302.61) ;
%Straight Lines [id:da42654071851324526] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (315.07,81.27) -- (391.07,302.61) ;
%Straight Lines [id:da053541002133335125] 
\draw    (192.62,241.7) -- (313.85,82.86) ;
\draw [shift={(315.07,81.27)}, rotate = 127.35] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (416.4,231) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle |\alpha \rangle $};
% Text Node
\draw (160.4,21.6) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle |\beta \rangle $};
% Text Node
\draw (394,154.6) node [anchor=north west][inner sep=0.75pt]    {$|\psi \rangle $};
% Text Node
\draw (403.33,281) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle U|\psi \rangle $};
% Text Node
\draw (316.67,60) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle G|\psi \rangle $};

\end{tikzpicture}
\caption{Representación en un plano de la iteración de Grover como dos simetrías.}
\end{figure}\ \linebreak
Por tanto el objetivo se interpreta como acercar el vector $\ket{\psi}$ al eje vertical, es decir al vector $\ket{\beta}$ que son la suma de todos los estados que son solución.\\
\linebreak
Para ello se realizarán dos operaciones. Primero se realizará una simetría respecto del eje horizontal, es decir respecto de $\ket{\alpha}$. Seguido de otra simetría pero respecto del vector $\ket{\psi}$. El resultado de estas dos simetrías es por tanto el de una rotación en el plano que llamaremos por ahora $G$. Si suponemos que $\sqrt{\frac{N-M}{N}} = \cos \frac{\theta}{2}$ y describimos el vector $\ket{\psi}$ como $\cos \frac{\theta}{2} \ket{\alpha} + \sin \frac{\theta}{2} \ket{\beta}$, entonces se puede expresar la operación final como una rotación de ángulo $\theta$, con $0<\theta\leq \frac{\pi}{2}$.\\
\linebreak
Por tanto como muestra la figura 3, $G$ lleva el vector $\ket{\psi}$ a
\begin{equation}
G\ket{\psi} = \cos \frac{3\theta}{2}\ket{\alpha} + \sin \frac{3\theta}{2} \ket{\beta}
\end{equation}
Si queremos acercarnos al vector $\ket{\beta}$ bastará entonces aplicar repetidas veces $G$.
\begin{equation}
G^k \ket{\psi} = \cos \frac{(2k+1)\theta}{2}\ket{\alpha} + \sin \frac{(2k+1)\theta}{2} \ket{\beta}
\end{equation}
En cuanto al número de veces que aplicaremos $G$, es muy fácil de determinar teniendo en cuenta que $\ket{\psi} = \sqrt{\frac{N-M}{N}}\ket{\alpha} \sqrt{\frac{M}{N}}\ket{\beta}$, por lo que para llevar $\ket{\psi}$ a $\ket{\beta}$ habría que rotar con un ángulo de $\arccos \sqrt{\frac{M}{N}}$. Entonces, sea $CI(x)$ el entero más cercano a $x$, las veces que tenemos que aplicar la operación $G$ será
\begin{equation}
R = CI\left( \frac{\arccos \sqrt{M/N}}{\theta} \right)
\end{equation}
Esta expresión nos da el valor exacto de las veces que hay que aplicar $G$, sin embargo podemos conseguir una expresión más simple y cómoda de trabajar con unas hipótesis adicionales. Supongamos que $M \leq \frac{N}{2}$, queremos buscar una cota superior para $R$, entonces tenemos que
\begin{equation}
\frac{\theta}{2} \geq \sin \frac{\theta}{2} = \sqrt{\frac{M}{N}}
\end{equation}
entonces,
\begin{equation}
R \leq \left\lceil \frac{\pi}{2\theta} \right\rceil \leq \left\lceil \frac{\pi}{4} \sqrt{\frac{N}{M}} \right\rceil
\end{equation}
Esto nos muestra que el algoritmo tiene una complejidad de $R = O(\sqrt{N/M})$, que requiere ese número iteraciones de $G$ para encontrar con una alta probabilidad la solución, que es una mejora cuadrática respecto al método clásico con una complejidad de $O(N/M)$.\\

Veamos ahora cómo se traduce estas operaciones en términos de puertas cuánticas. Consideramos entonces el siguiente circuito:

\begin{figure}[h]
\centering
\scalebox{1.2}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \nghost{\ket{x}} & \rstick{/^{n}} \qw_(0.0){\ket{\mathbf{0}}} & \qw & \gate{\mathrm{H}^{\otimes n}} & \qw & \lstick{/^{n}} \qw & \multigate{1}{\hspace{0.3cm}\mathrm{U_f}\hspace{0.3cm}} & \qw & \lstick{/^{n}} \qw & \gate{\mathrm{H^{\otimes n}}} & \gate{2\ket{\mathbf{0}}\bra{\mathbf{0}} - I} & \gate{\mathrm{H^{\otimes n}}} & \qw & \lstick{/^{n}} \qw & \meter \\
	 \nghost{\ket{y}} & \qw_(0.0){\ket{1}} & \qw^(0.0){\ket{\varphi_0}} & \gate{\mathrm{H}} & \qw^(0.0){\ket{\varphi_1}} & \qw & \nghost{\hspace{0.3cm}\mathrm{U_f}\hspace{0.3cm}} \qw & \qw^(0.0){\ket{\varphi_2}} & \qw & \qw & \qw & \qw & \qw^(0.0){\ket{\varphi_3}} & \qw & \qw \\}}
\caption{Circuito del algoritmo de Grover con una iteración.}
\end{figure}\ \linebreak
Es decir, en término de matrices, sería
\begin{equation}
\left((H^{\otimes n} \cdot (2\ket{\mathbf{0}}\bra{\mathbf{0}} - I) \cdot H^{\otimes n}) \otimes I \right) U_f(H^{\otimes n}\otimes H)\ket{\varphi_0}
\end{equation}
observamos que se puede simplificar la siguiente expresión obteniendo
\begin{equation}
H^{\otimes n} \cdot (2\ket{\mathbf{0}}\bra{\mathbf{0}} - I) \cdot H^{\otimes n} = 2\ket{\psi}\bra{\psi} - I
\end{equation}
por lo que podemos llamar como iteración de Grover a la operación $G = \left( (2\ket{\psi}\bra{\psi} - I) \otimes I\right) U_f$, que es la rotación de ángulo $\theta$ que hemos visto antes.\\
Empezamos como siempre con $n$ qubits y el qubit de control en el estado $\ket{\varphi_0} = \ket{\mathbf{0}, 1}$ y lo ponemos en estado de superposición con la puerta de Hadamard $H^{\otimes n}\otimes H$ obteniendo el estado
\begin{equation}
\ket{\varphi_1} = \frac{1}{\sqrt{N}}\sum_{\mathbf{x}\in\{ 0, 1\}^n}\ket{\mathbf{x}} \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\end{equation}
A continuación le aplicamos el oráculo $U_f$ a $\ket{\varphi_1}$ y se obtiene
\begin{equation}
\ket{\varphi_2} = \frac{1}{\sqrt{N}} \sum_{\mathbf{x}\in\{ 0, 1\}^n} (-1)^{f(\mathbf{x})} \ket{\mathbf{x}} \left[ \frac{\ket{0} - \ket{1}}{\sqrt{2}} \right]
\end{equation}
que es la misma expresión \ref{eq431} que se llega en el algoritmo anterior. Observamos que esto es cambiar el signo de aquellos vectores $\ket{\mathbf{x}}\in\{0,1\}^n$ que cumplen $f(\mathbf{x}) = 1$, es decir está haciendo la simetría respecto del eje horizontal correspondiente al vector de no soluciones $\ket{\alpha}$.\\
\linebreak
Finalmente realizaremos la simetría respecto del vector $\ket{\psi}$ que corresponde con la matriz unitaria $2\ket{\psi}\bra{\psi} - I$.
Esto se puede ver fácilmente si tomamos por ejemplo un vector arbitrario $\ket{u}$. Consideramos primero $\ket{\omega}$ que cumple que $\{ \ket{\psi}, \ket{\omega} \}$ forma una base ortonormal. Entonces podemos expresar $\ket{u} = a\ket{\psi} + b\ket{\omega}$, por tanto tenemos que $\left( 2\ket{\psi}\bra{\psi} - I \right) \ket{u}$ es
\begin{equation}
\begin{split}
\left( 2\ket{\psi}\bra{\psi} - I \right) \left( a\ket{\psi} + b\ket{\omega} \right)
&=
2 \ket{\psi}\bra{\psi} \left( a\ket{\psi} + b\ket{\omega} \right) - \left( a\ket{\psi} + b\ket{\omega} \right)
\\ &=
2a \ket{\psi}\bra{\psi} \left( \ket{\psi} \right) + 2b \ket{\psi}\bra{\psi} \left( \ket{\omega} \right) - \left( a\ket{\psi} + b\ket{\omega} \right)
\\ &=
2a \braket{\psi \mid \psi} \ket{\psi} + 2b \braket{\psi \mid \omega} \ket{\psi} - \left( a\ket{\psi} + b\ket{\omega} \right)
\end{split}
\end{equation}
Como $\{ \ket{\psi}, \ket{\omega} \}$ es una base ortonormal, se cumple que $\braket{\psi \mid \psi} = 1$ y que $\braket{\psi \mid \omega} = 0$, por tanto
\begin{equation}
\begin{split}
\left( 2\ket{\psi}\bra{\psi} - I \right) \left( a\ket{\psi} + b\ket{\omega} \right)
&=
2a \ket{\psi} - \left( a\ket{\psi} + b\ket{\omega} \right)
\\ &=
a\ket{\psi} - b\ket{\omega}
\end{split}
\end{equation}
Por tanto se ve que es una simetría respecto del vector $\ket{\psi}$. Además podemos ver que $\ket{\psi}\bra{\psi}$ es una proyección sobre $\ket{\psi}$.

\begin{figure}[!h]
\centering

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,322); %set diagram left start at 0, and has height of 322

%Shape: Axis 2D [id:dp5288380819499159] 
\draw  (169.2,241.7) -- (410.24,241.7)(192.62,25.6) -- (192.62,264.07) (403.24,236.7) -- (410.24,241.7) -- (403.24,246.7) (187.62,32.6) -- (192.62,25.6) -- (197.62,32.6)  ;
%Straight Lines [id:da8922674117582208] 
\draw    (192.62,241.7) -- (365.84,181.27) ;
\draw [shift={(367.73,180.61)}, rotate = 160.77] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8868994576415257] 
\draw    (192.62,241.7) -- (334.55,300.51) ;
\draw [shift={(336.4,301.27)}, rotate = 202.51] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da42654071851324526] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (272.4,98.61) -- (336.4,301.27) ;
%Straight Lines [id:da053541002133335125] 
\draw    (192.62,241.7) -- (271.43,100.36) ;
\draw [shift={(272.4,98.61)}, rotate = 119.14] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da1877872551975237] 
\draw    (192.62,241.7) -- (306.51,201.93) ;
\draw [shift={(308.4,201.27)}, rotate = 160.75] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da12344946871649554] 
\draw    (308.4,201.27) -- (422.29,161.51) ;
\draw [shift={(424.18,160.85)}, rotate = 160.75] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8947714698521929] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (424.18,160.85) -- (336.4,301.27) ;
%Straight Lines [id:da7524338999392948] 
\draw  [dash pattern={on 0.84pt off 2.51pt}]  (272.4,98.61) -- (424.18,160.85) ;

% Text Node
\draw (416.4,231) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle |\alpha \rangle $};
% Text Node
\draw (160.4,21.6) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle |\beta \rangle $};
% Text Node
\draw (338.67,153.93) node [anchor=north west][inner sep=0.75pt]    {$|\psi \rangle $};
% Text Node
\draw (341,281.67) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle |u\rangle =a|\psi \rangle +b|\omega \rangle $};
% Text Node
\draw (212,72) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle ( 2|\psi \rangle \langle \psi |-I) |u\rangle =a|\psi \rangle -b|\omega \rangle $};
% Text Node
\draw (426.18,164.25) node [anchor=north west][inner sep=0.75pt]    {$2a|\psi \rangle $};


\end{tikzpicture}
\end{figure}


\newpage

\subsection{Algoritmo de Periodicidad de Simon}
Veremos ahora el algoritmo de Simon que trata de buscar patrones que se repiten en funciones. Combinaremos en el algoritmo procedimientos cuánticos que hemos visto y también operaciones clásicas.\\
\linebreak
Consideramos entonces una función $f:\{0,1\}^n \longrightarrow \{0,1\}^n$, que como siempre podemos evaluar pero no conocemos su definición. Además sabemos que existe una cadena binaria $\mathbf{c} \in \{0,1\}^n$ tal que para toda cadena $\mathbf{x},\mathbf{y}\in\{0,1\}^n$ tenemos que se cumple
\begin{equation}
f(\mathbf{x}) = f(\mathbf{y}) \; \text{si y sólo si} \; \mathbf{x} = \mathbf{y}\oplus \mathbf{c}
\end{equation}
donde $\oplus$ es la suma módulo 2 aplicado dígito a dígito. Es decir, que se cumple que $f(\mathbf{y}) = f(\mathbf{y}\oplus\mathbf{c})$. Esto es que los valores de $f$ se repiten en un determinado patrón y llamaremos entonces $\mathbf{c}$ como el periodo de la función, que es el objetivo del algoritmo.\\
\linebreak
Sea entonces $U_f$ la matriz unitaria que define el oráculo, que lleva $\ket{\mathbf{x}, \mathbf{y}}$ a $\ket{\mathbf{x}, \mathbf{y}\oplus f(\mathbf{x})}$, que podemos ver de nuevo que es su propia inversa. 

\begin{figure}[h]
\centering
\scalebox{1.2}{
\Qcircuit @C=1.0em @R=0.8em @!R {
	 \lstick{\ket{\mathbf{x}}} & \qw & \lstick{/^{n}} \qw & \multigate{1}{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} & \qw & \lstick{/^{n}} \qw & \rstick{\ket{\mathbf{x}}} \\
	 \lstick{\ket{\mathbf{y}}} & \qw & \lstick{/^{n}} \qw & \nghost{\hspace{0.2cm}\mathrm{U_f}\hspace{0.2cm}} \qw & \qw & \lstick{/^{n}} \qw & \rstick{\ket{\mathbf{y}\oplus f(\mathbf{x})}}
}}
\end{figure}\ \linebreak
Observamos que en este caso tenemos $2n$ qubits y si ponemos los últimos $n$ qubits en el estado $\ket{\mathbf{y}} = \ket{\mathbf{0}}$, nos permitiría evaluar la función con el oráculo
\begin{equation}
U_f\ket{\mathbf{x}, \mathbf{0}} = \ket{\mathbf{x}, \mathbf{0}\oplus f(\mathbf{x})} = \ket{\mathbf{x}, f(\mathbf{x})}
\end{equation}
Teniendo en cuenta esto, consideramos el siguiente circuito y veamos las operaciones paso a paso.

\begin{figure}[h]
\centering
\scalebox{1.2}{
\Qcircuit @C=1.0em @R=0.8em @!R { \\
	 \nghost{\ket{x}} & \rstick{/^{n}} \qw_(0.0){\ket{\mathbf{0}}} & \qw & \gate{\mathrm{H}^{\otimes n}} & \qw & \lstick{/^{n}} \qw & \multigate{1}{\hspace{0.3cm}\mathrm{U_f}\hspace{0.3cm}} & \qw & \lstick{/^{n}} \qw & \gate{\mathrm{H^{\otimes n}}} & \qw & \meter \\
	 \nghost{\ket{y}} & \qw_(0.0){\ket{\mathbf{0}}} & \qw^(0.0){\ket{\varphi_0}} & \lstick{/^{n}} \qw & \qw^(0.0){\ket{\varphi_1}} & \qw & \nghost{\hspace{0.3cm}\mathrm{U_f}\hspace{0.3cm}} \qw & \qw^(0.0){\ket{\varphi_2}} & \qw & \lstick{/^{n}} \qw & \qw^(0.0){\ket{\varphi_3}} & \qw \\}}
\end{figure}\ \linebreak
Esto en término de matrices sería
\begin{equation}
(H^{\otimes n}\otimes I) U_f (H^{\otimes n}\otimes I)\ket{\mathbf{0}, \mathbf{0}}
\end{equation}
Comenzamos con los qubits en el estado $\ket{\varphi_0} = \ket{\mathbf{0}, \mathbf{0}}$ y lo ponemos en estado de superposición con la matriz de Hadamard. Recordamos que el resultado de la expresión \ref{eq427}, sabemos que esto es
\begin{equation}
\ket{\varphi_1} =
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{0,1\}^n} \ket{\mathbf{x}, \mathbf{0}}
\end{equation}
Aplicamos el oráculo $U_f$ y recordando que es lineal tenemos,
\begin{equation}
\ket{\varphi_2} =
\frac{1}{\sqrt{2^n}} \sum_{\mathbf{x}\in\{0,1\}^n} \ket{\mathbf{x}, f(\mathbf{x})}
\end{equation}
Finalmente, aplicamos de nuevo la matriz de Hadamard teniendo en cuenta la expresión \ref{gHadamard} y obtenemos
\begin{equation}
\ket{\varphi_3} =
\frac{ \sum_{\mathbf{x}\in\{0,1\}^n} \sum_{\mathbf{z}\in\{0,1\}^n} (-1)^{\langle \mathbf{z}, \mathbf{x} \rangle} \ket{\mathbf{x}, f(\mathbf{x})} } {2^n}
\end{equation}
Observamos entonces que en el sumatorio, para cada $\mathbf{x}$ y para cada $\mathbf{z}$ tenemos que $\ket{\mathbf{z}, f(\mathbf{x})}$ coincide con $\ket{\mathbf{z}, f(\mathbf{x}\oplus\mathbf{c})}$ por la periodicidad de la función. Por tanto si agrupamos los pares, sus coeficientes serán
\begin{equation}
\begin{split}
\frac{(-1)^{\langle\mathbf{z}, \mathbf{x}\rangle} + (-1)^{\langle\mathbf{z}, \mathbf{x}\oplus\mathbf{c}\rangle}}{2}
= 
\frac{(-1)^{\langle\mathbf{z}, \mathbf{x}\rangle} + (-1)^{\langle\mathbf{z}, \mathbf{x}\rangle \oplus \langle \mathbf{z}, \mathbf{c}\rangle}}{2}
\\=
\frac{(-1)^{\langle\mathbf{z}, \mathbf{x}\rangle} + (-1)^{\langle\mathbf{z}, \mathbf{x}\rangle}(-1)^{ \langle \mathbf{z}, \mathbf{c}\rangle}}{2}
=
\frac{(-1)^{\langle\mathbf{z}, \mathbf{x}\rangle} (1 + (-1)^{ \langle \mathbf{z}, \mathbf{c}\rangle})}{2}
\end{split}
\end{equation}
Entonces, si discutimos la expresión según el valor de $\langle \mathbf{z}, \mathbf{c} \rangle$ tenemos que si $\langle \mathbf{z}, \mathbf{c} \rangle = 1$, la expresión anterior se anula. Si $\langle \mathbf{z}, \mathbf{c} \rangle = 0$ obtenemos el valor $\pm 1$. Por tanto si medimos los $n$ primeros qubits tras el circuito, obtendremos las cadena binarias $\mathbf{z}$ que cumplen que $\langle \mathbf{z}, \mathbf{c} \rangle = 0$. Lo que nos queda por hacer es sólamente plantear una ecuación lineal con las cadenas resultantes para obtener $\mathbf{c}$.

\newpage

\subsection{Algoritmo de Factorización de Shor}
El problema de factorizar un número compuesto tiene su interés en la criptografía, ya que este se basa en que no hay un algoritmo eficiente que resuelva el problema. Sin embargo la computación cuántica nos ofrece un algoritmo que permite descomponer un número compuesto en sus factores primos de manera exponencialmente más rápido que el mejor algoritmo clásico que se conoce hasta la fecha.\\
\linebreak
Antes de entrar en detalle con el algoritmo veremos una herramienta que es esencial para el proceso de este algoritmo, además de otros también. Se trata de la Transformada Cuántica de Fourier, que nos permite aproximar el valor de la fase de un estado de un qubit, algo realmente importante que nos permite resolver por ejemplo el problema de encontrar el orden de un elemento y también al problema de factorizar un número compuesto.\\

Veamos primero en detalle la transformada cuántica de Fourier. Recordemos primero la transformada discreta de Fourier, que lleva un vector de complejos $(x_0, \ldots, x_{N-1})$ a otro de misma dimensión $y_0, \ldots, y_{N-1}$ definido cada componente como
\begin{equation}
y_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_j e^{2\pi i j k /N}
\end{equation}
Por tanto queremos que la transformada cuántica de Fourier actúe sobre una base ortonormal $\{ \ket{j} \mid 0 \leq j \leq N-1 \}$ de manera que a cada elemento de la base
\begin{equation}
\ket{j} \longrightarrow \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi i j k /N} \ket{k}
\end{equation}
Entonces, si se toma un vector arbitrario, la transformada cuántica de Fourier lo llevará a
\begin{equation}
\sum_{j=0}^{N-1} x_j \ket{j}
\longrightarrow
\sum_{k=0}^{N-1} y_k \ket{k}
\end{equation}
donde las amplitudes $y_k$ son la transformada discreta de Fourier aplicado a $x_j$. Esto es la definición general que podemos dar sobre la transformada cuántica de Fourier, sin embargo hay una expresión con la que nos resultará más cómoda trabajar posteriormente. Además nos permitirá demostrar fácilmente que la transformada cuántica de Fourier no es sólo lineal sino también unitaria, que es importante que cumpla esto último.\\
\linebreak
Tomamos a partir de ahora $N = 2^n$ para $n$ entero, y la base ortonormal $\{\ket{0}, \ldots, \ket{2^n-1}\}$ representado el estado de $n$ qubits. Entonces para cada $\ket{j}$ podemos escribirlo en su representación binaria con $j \equiv j_1 j_2 \ldots j_n$ de manera que $j = j_1 2^{n-1} + j_2 2^{n-2} + \ldots + j_n 2^0$. Consideraremos también la notación binaria para fracciones $0.j_1 j_2 \ldots j_m$ para representar el valor $j_1 2^{-1} + j_2 2^{-2} + \ldots + j_m ^{-m}$.
Tomamos entonces un elemento de la base $\ket{j}$ y le aplicamos la transformada cuántica de Fourier 
\begin{equation}
\begin{split}
\ket{j} &\rightarrow 
\frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1} e^{2\pi i j k /2^n} \ket{k}
\\ &=
\frac{1}{\sqrt{2^n}} \sum_{k_1=0}^{1} \ldots \sum_{k_n=0}^{1} e^{2\pi i j \left( \sum_{l=1}^{n} k_l 2^{-l} \right)} \ket{k_1\ldots k_n}
\end{split}
\end{equation}
donde hemos sustituido $k$ por su expresión en binario $k_1\ldots k_n$ y $\frac{k}{2^n} = \frac{k_1 2^{n-1} + k_2 2^{n-2} k_n 2^0}{2^n} = \sum_{l=1}^{n} k_l 2^{-l}$. Separamos ahora cada vector por el producto tensorial y simplicamos la expresión
\begin{equation}
\begin{split}
\ket{j} &\rightarrow
\frac{1}{\sqrt{2^n}} \sum_{k_1=0}^{1} \ldots \sum_{k_n=0}^{1} \left( \prod_{l=1}^{n} e^{2\pi i j k_l 2^{-l}} \right) \ket{k_1\ldots k_n}
\\ &=
\frac{1}{\sqrt{2^n}} \sum_{k_1=0}^{1} \ldots \sum_{k_n=0}^{1} \bigotimes_{l=1}^{n} e^{2\pi i j k_l 2^{-l}} \ket{k_l}
\\ &=
\frac{1}{\sqrt{2^n}} \bigotimes_{l=1}^{n} \left[ \sum_{k_l=0}^{1} e^{2\pi i j k_l 2^{-l}} \ket{k_l} \right]
\\ &=
\frac{1}{\sqrt{2^n}} \bigotimes_{l=1}^{n} \left[ \ket{0} + e^{2\pi i j 2^{-l}} \ket{1} \right]
\end{split}
\end{equation}
Vamos a analizar por un momento en detalle el valor de $e^{2\pi i j 2^{-l}}$. Si tomamos por ejemplo el valor de $l=1$ y expresamos $j$ en binario tenemos que $\frac{j}{2^1} = \frac{j_1 2^{n-1} + j_2 2^{n-2} + \ldots + j_n 2^{0}}{2} = j_1 2^{n-2} + j_2 2^{n-3} + \ldots + j_{n-1} 2^{0} + j_n 2^{-1}$ lo que podemos separar $e^{2\pi i j 2^{-l}} = e^{2\pi i \left( j_1 2^{n-2} + j_2 2^{n-3} + \ldots + j_{n-1} 2^{0} \right)} \cdot e^{2\pi i j_n 2^{-1}}$. Ahora teniendo en cuenta que $\left( j_1 2^{n-2} + j_2 2^{n-3} + \ldots + j_{n-1} 2^{0} \right)$ es un número entero, tenemos que $e^{2\pi i j 2^{-l}} = e^{2\pi i} \cdot e^{2\pi i j_n 2^{-1}} = 1 \cdot e^{2\pi i 0.j_n}$ donde hemos expresado $j_n 2^{-1}$ con su expresión binaria para fracciones.\\
Entonces en general para un valor en concreto de $l = m$ podemos expresar $e^{2\pi i j 2^{-m}} = e^{2\pi i 0.j_{n-m+1}\cdots j_{n}}$.
\begin{equation}
\begin{split}
\ket{j} &\rightarrow
\frac{1}{\sqrt{2^n}} \bigotimes_{l=1}^{n} \left[ \ket{0} + e^{2\pi i j 2^{-l}} \ket{1} \right]
\\ &=
\frac{\left( \ket{0} + e^{2\pi i 0.j_n}\ket{1} \right) \left( \ket{0} + e^{2\pi i 0.j_{n-1}j_n}\ket{1} \right) \cdots \left( \ket{0} + e^{2\pi i 0.j_1 j_2 \ldots j_n}\ket{1} \right)}{\sqrt{2^n}}
\end{split}
\end{equation}
Esta última expresión nos resultará de mucha utilidad a pesar de que a primera vista parece incómodo para trabajar. Esto nos permitirá construir un circuito de manera muy intuitiva para aplicar la transformada cuántica de Fourier. Para ello consideramos primero la puerta $R_k$ cuya matriz es
\begin{equation}
R_k =
\begin{bmatrix}
1 & 0 \\
0 & e^{2\pi i/2^k}
\end{bmatrix}
\end{equation}

\begin{figure}[h] \label{fig_qft}
\centering
\includegraphics[scale=0.65]{qft}
\caption{Fuente: Nielsen \cite{nielsen2001quantum}}
\end{figure}\ \linebreak
Comenzaremos con el estado $\ket{j_1 j_2 \ldots j_n}$. Si le aplicamos la puerta de Hadamard al primero estado, podemos expresar este como
\begin{equation}
\frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1}\ket{1} \right)
\ket{j_2 \ldots j_n}
\end{equation}
ya que el valor de $e^{2\pi i 0.j_1}$ es
\begin{equation}
\begin{cases}
j_1 = 0 \longrightarrow e^{2\pi i \cdot 0} = e^0 = 1 \\
j_1 = 1 \longrightarrow e^{2\pi i \cdot 0.\text{1}} = e^{2\pi i \cdot 2^{-1}} = e^{\pi i} = -1
\end{cases}
\end{equation}
Le aplicamos a continuación la puerta controlada $R_2$ al qubit actual como qubit objetivo, y el qubit en el estado $\ket{j_2}$ como control.
Esto es
\begin{equation}
\begin{cases}
j_2 = 0 \longrightarrow \frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1} \ket{1} \right)
=
\frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1 0} \ket{1} \right) \\
j_2 = 1 \longrightarrow
\frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1}\cdot e^{2\pi i/2^2} \ket{1} \right)
=
\frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1 1}\cdot \ket{1} \right)
\end{cases}
\end{equation}
Por tanto, tenemos el estado
\begin{equation}
\frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1 j_2}\ket{1} \right)
\ket{j_2 \ldots j_n}
\end{equation}
Continuamos aplicando las puertas controladas $R_3$ hasta $R_n$ que añade un nuevo bit a la fase del estado, acabando finalmente en
\begin{equation}
\frac{1}{\sqrt{2}}\left( \ket{0} + e^{2\pi i 0.j_1 j_2\ldots j_n}\ket{1} \right)
\ket{j_2 \ldots j_n}
\end{equation}
De manera análoga realizamos el mismo proceso con el resto de qubits lo que nos permite obtener el estado final
\begin{equation}
\frac{1}{\sqrt{2^n}}
\left( \ket{0} + e^{2\pi i 0.j_1 j_2\ldots j_n}\ket{1} \right)
\left( \ket{0} + e^{2\pi i 0.j_2\ldots j_n}\ket{1} \right)
\ldots
\left( \ket{0} + e^{2\pi i 0.j_n}\ket{1} \right)
\end{equation}
Finalmente realizamos una operación de intercambio con la puerta de intercambio para obtener el orden adecuado y de esta manera obtenemos la transformada cuántica de Fourier
\begin{equation}
\frac{1}{\sqrt{2^n}}
\left( \ket{0} + e^{2\pi i 0.j_n}\ket{1} \right)
\left( \ket{0} + e^{2\pi i 0.j_{n-1} j_n}\ket{1} \right)
\ldots
\left( \ket{0} + e^{2\pi i 0.j_1 j_2\ldots j_n}\ket{1} \right)
\end{equation}
Con esto terminamos en el estado que buscábamos además de demostrar que la transformada cuántica de Fourier es unitaria pues está compuesto de operaciones unitarias.\\

Ahora veremos que la transformación cuántica de Fourier es esencial para el proceso de la estimación de la fase. Este último consiste en considerar una aplicación unitaria $U$ que tiene un autovector $\ket{u}$ con autovalor $e^{2\pi \varphi}$ donde se desconoce el valor de $\varphi$. Tenemos el objetivo de estimar el valor de $\varphi$ y para ello dispondremos de el oráculo que nos permitirá realizar la operación controlada de $U^{2^j}$.\\
Comenzaremos con dos registros de qubits, o dos conjuntos de qubits. El primero registro tendrá $t$ qubits en el estado $\ket{\mathbf{0}}$ con $t$ el número de bits que contendrá la aproximación de $\varphi$.\\
En el segundo registro se hallarán los qubits en el estado $\ket{u}$ con el número de qubits necesarios para almacenar $\ket{u}$. Entonces, la estimación de fase consistirá en dos partes. Primero le aplicaremos el circuito siguiente.

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{orden}
\caption{Fuente: Nielsen \cite{nielsen2001quantum}}
\end{figure}\ \linebreak
Primero aplicaremos la puerta de Hadamard que llevará a cada qubit al estado
\begin{equation}
\frac{\ket{0} + \ket{1}}{\sqrt{2}}
\end{equation}
Se le aplicará posteriormente las puertas controladas $U^{2^j}$ con $0\leq j \leq 2^{t-1}$. Si tomamos los qubits afectados por la primera puerta controlada $U^{2^0} = U$ tendremos
\begin{equation}
\begin{split}
^CU \left( \frac{\ket{0} + \ket{1}}{\sqrt{2}} \ket{u} \right) 
&= 
^CU \left( \frac{\ket{0, u} + \ket{1, u}}{\sqrt{2}} \right)
=
\frac{1}{\sqrt{2}} \left( ^CU\ket{0, u} + ^CU\ket{1, u} \right)
\\ &=
\frac{1}{\sqrt{2}} \left( \ket{0, u} + e^{2\pi i \varphi}\ket{1, u} \right)
=
\frac{1}{\sqrt{2}} \left( \ket{0} + e^{2\pi i \left(2^0 \varphi\right)} \ket{1} \right) \ket{u}
\end{split}
\end{equation}
Por tanto, deducimos de las demás puertas, el estado final de los qubits del primer registro serán
\begin{equation}
\frac{1}{\sqrt{2^t}}
\left( \ket{0} + e^{2\pi i 2^{t-1}\varphi} \ket{1} \right)
\left( \ket{0} + e^{2\pi i 2^{t-2}\varphi} \ket{1} \right)
\ldots
\left( \ket{0} + e^{2\pi i 2^{0}\varphi} \ket{1} \right)
\end{equation}
Por último aplicaremos la inversa de la transformada cuántica de Fourier, que consiste en darle la vuelta al circuito de la Figura \ref{fig_qft}. Supongamos que la mejor aproximación de $\varphi$ en $t$ bits es $\varphi  \simeq 0.\varphi_1 \ldots \varphi_t$, entonces reescribiendo la expresión anterior del estado en binario tendremos
\begin{equation}
\frac{1}{\sqrt{2^t}}
\left( \ket{0} + e^{2\pi i 0.\varphi_t} \ket{1} \right)
\left( \ket{0} + e^{2\pi i 0.\varphi_{t-1}\varphi_t} \ket{1} \right)
\ldots
\left( \ket{0} + e^{2\pi i 0.\varphi_1\varphi_2\ldots\varphi_t} \ket{1} \right)
\end{equation}
Esta expresión es exactamente la transformada cuántica de Fourier de $\ket{\varphi_1\ldots\varphi_t}$, por tanto aplicando la inversa obtendremos los valores de $\varphi  \simeq 0.\varphi_1 \ldots \varphi_t$. Para ello mediremos los $t$ qubits del primer registro obteniendo una buena aproximación del valor de $\varphi$.\\

Esta herramienta nos resolverá el problema de encontrar el orden de un elemento y también al problema de factorizar un número compuesto, que son equivalentes entre sí. Veremos primero el problema de encontrar el orden de un elemento y veremos posteriormente que el problema de factorización lo podremos transformar en un problema de encontrar el orden.\\
\linebreak
Consideremos entonces dos enteros positivos $x$ y $N$ tal que $x<N$ sin factores comunes, llamaremos entonces al \textit{orden} de $x \modd N$ al menor entero positivo tal que $x^r =  1\modd N$. Entonces, el algoritmo cuántico para encontrar el orden es simplemente aplicar el algoritmo de estimación de fase con el operador unitario
\begin{equation}
U\ket{y} = \ket{x y \modd N}
\end{equation}
con $y \in \{0, 1\}^L$ siendo $L$ el número de qubits necesarios para representar $N$ en binario. Consideramos entonces el estado
\begin{equation}
\ket{u_s} =
\frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-2\pi isk/r}\ket{x^k \modd N}
\end{equation}
con $0\leq s \leq r-1$, que son autovectores de $U$, ya que
\begin{equation}
\begin{split}
U\ket{u_s} &=
U\left( \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-2\pi isk/r}\ket{x^k \modd N} \right) =
\frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-2\pi isk/r} U \ket{x^k \modd N}
\\ &=
\frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-2\pi isk/r}\ket{x^{k+1} \modd N}
\end{split}
\end{equation}
Desarrollamos la expresión y sacando factor común obtenemos
\begin{equation}
\begin{split}
U\ket{u_s} &=
\frac{1}{\sqrt{r}} \left(
e^{\frac{-2\pi is}{r}0} \ket{x^1 \modd N} +
e^{\frac{-2\pi is}{r}1} \ket{x^2 \modd N} + \ldots +
e^{\frac{-2\pi is}{r}(r-1)} \ket{x^r \modd N} \right)
\\ &=
e^{2\pi is/r} \left[
\frac{1}{\sqrt{r}} \left(
e^{\frac{-2\pi is}{r}1} \ket{x^1 \modd N} +
e^{\frac{-2\pi is}{r}2} \ket{x^2 \modd N} + \ldots +
e^{\frac{-2\pi is}{r}r} \ket{x^r \modd N} \right) \right]
\end{split}
\end{equation}
Teniendo en cuenta ahora que $e^{-2\pi is} = 1 = e^0$ y que $x^r = 1 \modd N = x^0 \modd N$, tenemos que
\begin{equation}
\begin{split}
U\ket{u_s} &=
e^{2\pi is/r} \left[
\frac{1}{\sqrt{r}} \left(
e^{\frac{-2\pi is}{r}1} \ket{x^1 \modd N} +
e^{\frac{-2\pi is}{r}2} \ket{x^2 \modd N} + \ldots +
e^{\frac{-2\pi is}{r}0} \ket{x^0 \modd N} \right) \right]
\\ &=
e^{2\pi is/r} \left[ \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-2\pi isk/r}\ket{x^k \modd N} \right]
= e^{2\pi is/r} \ket{u_s}
\end{split}
\end{equation}
Por tanto aplicando el algoritmo de estimación fase, obtendremos una aproximación del valor de $\varphi \simeq s/r$, del que podemos obtener fácilmente el valor de $r$.\\

Una vez que sabemos hallar el orden de un elemento, usaremos esta herramienta y dos teoremas para resolver el problema de factorización. La idea es reducir el problema de factorización en el problema de encontrar el orden de un elemento. Vamos a desarrollar primero algunos conceptos necesarios de teoría de números.\\
\linebreak
Presentamos primero el algoritmo de Euclides para encontrar el máximo común divisor de dos números. Supongamos entonces $a$, $b$ dos enteros de manera que $a > b$.
\begin{teo} \label{teoEu}
Sea entonces $r$ el resto de la división de $a$ entre $b$. Si se da que $r=0$, tenemos que se cumple
\begin{equation}
gcd(a,b) = gcd(b,r)
\end{equation}
donde $gcd(a,b)$ denota el máximo común divisor de $a$ y $b$.
\end{teo}
El algoritmo de Euclides consiste en dividir $a$ entre $b$ resultando en $k_1$ como cociente y un resto $r_1$, $a=k_1 b + r_1$. Por el teorema \ref{teoEu} tenemos que $gcd(a,b) = gcd(b,r_1)$. Si repetimos el proceso con $b$ dividido por $r_1$ tenemos de nuevo que $b = k_2 r_1 + r_2$. Y de nuevo por el teorema se tiene $gcd(a,b) = gcd(b,r_1) = gcd(r_1, r_2)$. Siguiendo este proceso repetidas veces hasta obtener un resto $0$, $r_m = k_{m+1}r_{m+1}$ para algún $m$. Entonces tenemos que $gcd(a, b) = gcd(r_m, r_{m+1}) = r_{m+1}$.\\
\linebreak
Veamos ahora el coste de este algoritmo. Supongamos que $a$ y $b$ pueden ser representadas por cadenas binarias de longitud $L$. Como los cocientes $k_i$ y restos $r_i$ son menores que $a$, lo podremos representar con cadenas de longitud $L$. Veamos ahora que se cumple que para cada $i$, $r_{i+2} \leq r_i /2$.
\begin{itemize}
\item Supongamos que $r_{i+1} \leq r_i/2$, entonces como $r_{i+2} \leq r_{i+1}$ tenemos que $r_{i+2} \leq r_i /2$.

\item Supongamos que $r_{i+1} > r_i/2$. Como $r_i = 1\cdot r_{i+1} + r_{i+2}$ tenemos que $r_{i+2} = r_i - r_{i+1} \leq r_i/2$.

\end{itemize}
Como $r_{i+2} \leq r_i/2$, el resto se reduce al menos a la mitad cada dos iteraciones. Como el algoritmo para cuando el resto se anula, tenemos que como máximo el proceso de división y resto se tiene que iterar como máximo un número de $2\lceil \log a \rceil = O(L)$ veces. Como cada proceso de división y resto llevan $O(L^2)$ operaciones, tenemos que el coste total del algoritmo de Euclides es de $O(L^3)$.\\
\linebreak
Veamos ahora los dos teoremas que nos ayudarán en reducir el problema de factorización.
%Supongamos entonces $N$ y $x$ enteros positivos con $1 \leq x < N$, consideramos $r$ el orden de $x \modd N$. 

\begin{teo}
Supongamos que $N$ es un número compuesto representado en $L$ bits y $x$ es la solución no trivial de $x^2 = 1 \modd N$ con $1\leq x\leq N$, es decir que $x \neq \pm 1 \modd N$. Entonces se da que al menos uno de $gcd(x-1, N)$ y $gcd(x+1, N)$ es un factor primo no trivial de $N$ que puede ser calculado en un número de $O(L^3)$ operaciones.
\end{teo}

\begin{proof}
Como $x^2 = 1 \modd N$, entonces $N$ divide a $x^2-1 = (x+1)(x-1)$ por tanto $N$ tiene que tener factor común con $(x+1)$ ó con $(x-1)$. Tenemos por hipótesis que $1\leq x\leq N$ por tanto $x-1 < x+1 < N$, el factor común no puede ser $N$. Empleando entonces el algoritmo de Euclides que hemos visto antes para calcular $gcd(x-1, N)$ y $gcd(x+1, N)$, obteniendo un factor no trivial de $N$ en $O(L^3)$ operaciones.
\end{proof}

Definimos la función de Euler $\varphi(n)$ como el número de enteros positivos menores que $n$ coprimo con él. Si $p$ es primo, todos los números menores a él son coprimos con $p$, entonces $\varphi(p) = p-1$. Si se toma $p^\alpha$ una potencia de $p$, los únicos coprimos con $p^\alpha$ son sus múltiplos $p, 2p, 3p, \ldots, (p^{\alpha-1}-1)p$, por tanto
\begin{equation}
\varphi(p^\alpha) = (p^\alpha - 1) - (p^{\alpha-1}-1) = p^{\alpha-1}(p-1)
\end{equation}


\begin{lem} \label{lem1}
Sea $p$ un primo impar. Sea $2^d$ la mayor potencia de $2$ que divide a $\varphi(p^\alpha)$, con $\varphi(n)$ siendo la función de Euler y $p^\alpha$ una potencia de $p$. Entonces con una probabilidad exacta de $1/2$, se tiene que $2^d$ divide el orden de un $x \modd p^\alpha$ escogido aleatoriamente de $\mathbb{Z}_{p^\alpha}^{*}$.
\end{lem}

\begin{proof}
Como $p$ es primo impar, tenemos que $\varphi(p^\alpha) = p^{\alpha-1}(p-1)$ es par y por tanto $d\geq 1$. Sabemos que $\mathbb{Z}_{p^\alpha}^{*}$ es cíclico, es decir, existe $g$ elemento de $\mathbb{Z}_{p^\alpha}^{*}$ tal que, cualquier elemento se puede escribir como $g^k \modd p^\alpha$ para $k$ de $1$ a $\varphi(p^\alpha)$. Observamos que $g^{\varphi(p^\alpha)} = 1 \modd p^\alpha$ que es el elemento nulo de $\mathbb{Z}_{p^\alpha}^{*}$. Sea entonces $r$ el orden de $g^k \modd p^\alpha$ y consideramos dos casos
\begin{itemize}
\item Suponemos primero que $k$ es impar. Como $g^{kr} = 1 = g^{\varphi(p^\alpha)} \modd p^\alpha$, se tiene que $\varphi(p^\alpha)\mid kr$. Y como $k$ es impar y $2^d$ que divide a $\varphi(p^\alpha)$ se tiene que $2^d \mid r$.

\item Suponemos ahora que $k$ es par. Entonces $g^{k\varphi(p^\alpha)/2} = \left( g^{\varphi(p^\alpha)}\right)^{k/2} = 1^{k/2} = 1 \modd p^\alpha$. Entonces $r\mid \varphi(p^\alpha)/2$ de donde podemos deducir que $2^d$ no divide a $r$.
\end{itemize}
Por tanto se tiene que si $k$ es impar $2^d\mid r$ y si $k$ es par se tiene $2^d \nmid r$.
\end{proof}

\begin{teo}
Consideramos $N = p_{1}^{\alpha^1}\ldots p_{m}^{\alpha^m}$ la factorización prima de un número compuesto impar positivo. Sea $x$ un entero elegido uniformente aleatorio de $\mathbb{Z}_{N}^{*}$, tal que $1 \leq x \leq N-1$ y $x$ es coprimo con $N$. Sea $r$ el orden de $x \modd N$. Entonces la probabilidad
\begin{equation}
P(r \text{ es par y } x^{r/2} \neq -1 \modd N) \geq 1 - \frac{1}{2^m}
\end{equation}
\end{teo}

\begin{proof}
Vamos a probar que 
\begin{equation}
P(r \text{ es impar ó } x^{r/2} = -1 \modd N) \leq  \frac{1}{2^m}
\end{equation}
Sabemos que $\mathbb{Z}_{N}^{*}$ es isomorfo a producto cartesiano $\prod_{j} \mathbb{Z}_{p_{j}^{\alpha_j}}^{*}$. Escoger $x$ aleatoriamente es igual a escoger las coordenadas $x_j \in \mathbb{Z}_{p_{j}^{\alpha_j}}^{*}$ de manera independiente con $x = x_j \modd p_{j}^{\alpha_j}$.\\
Consideramos entonces $r_j$ el orden de $x_j \modd p_{j}^{\alpha_j}$, $2^{d_j}$ la mayor potencia de $2$ que divide a $r_j$ y $2^d$ la mayor potencia de $2$ que divide a $r$.\\
Vamos a probar que para que $r$ sea impar ó $x^{r/2} = -1 \modd N$ tiene que ocurrir que para todo $j$, $d_j$ tome el mismo valor.
\begin{itemize}
\item Supongamos que $r$ es impar. Como $r_j$ es el orden de las coordenadas de $(x_j)_j$ y $r$ es el orden de $x$, tenemos que $r_j\mid r$ para cada $j$. Por tanto $r_j$ es impar y la mayor potencia que lo divide es $1$ y se llega a que $d_j$ es $0$.

\item Supongamos ahora que $r$ es par, entonces no queda otra que $x^{r/2} = -1 \modd N$. Se tiene por tanto también que para cada $j$, $x^{r/2} = -1 \modd p_{j}^{\alpha_j}$. Como $x = x_j \modd p_{j}^{\alpha_j}$ tenemos que $(x_j)^{r/2} = -1 \modd p_{j}^{\alpha_j}$.\\
Si se cumple que $r_j \mid r/2$ entonces existe un $k$ tal que $r/2 = k\cdot r_j$ y $(x_j)^{r/2} = (x_j)^{k\cdot r_j} = (x_j^{r_j})^k = 1^k = 1 \modd p_{j}^{\alpha_j}$, llegando a contradicción. Entonces $r_j \nmid r/2$. Además tenemos que $r_j \mid r$.\\
De aquí podemos concluir que para cada $j$ se tiene que $r_j = 2$ ó $r_j = r$.\\
Si algún $j$, $r_j = r$, es fácil ver que para ese $j$, $d_j = d$. Pero si para algún $j$ se tiene que $r_j = 2$, entonces como ese $r_j \nmid r/2$ tenemos que $r/2$ es impar. Como $r = (r/2) \cdot 2)$ la mayor potencia de $2$ que lo divide es $2$ con $d = 1$. Como $r_j = 2$ la mayor potencia de $2$ que le divide es $2$ con $d_j = 1$, por lo que tanto se tiene que $d_j = d$.

\end{itemize}
Ahora sabemos que para que $r$ sea impar ó $x^{r/2} = -1 \modd N$ tiene que ocurrir que para todo $j$, $d_j$ tome el mismo valor y por el lema \ref{lem1} tenemos que con una probabilidad de $1/2$ pasa para un sólo $d_j$ y entonces para que tome el mismo valor, la probabilidad es de a lo sumo $1/2^m$.
\end{proof}

Entonces a partir de esto teoremas podemos sacar un algoritmo para factorizar consiste en los siguientes pasos. Todos los pasos se pueden realizar en un ordenador clásico de manera eficiente menos el paso número $4$ es el que realizaremos con un algoritmo cuántico.
\begin{itemize}
\item[1.]Si $N$ es par, devolvemos el factor $2$.

\item[2.]Determinar si se cumple $N = a^b$ para enteros $a\geq 1$ y $b \geq 2$. Devolver el factor $a$ en caso positivo.

\item[3.]Elegir aleatoriamente $x$ entre $1$ y $N-1$. Si $gcd(x,N)>1$ entonces devolvemos el factor $gcd(x,N)$.

\item[4.]Aplicamos el algoritmo cuántico para encontrar el orden $r$ de $x \modd N$.

\item[5.]Si $r$ es par y $x^{r/2}\neq -1 \modd N$, comprobar si $gcd(x^{r/2}-1, N)$ y $gcd(x^{r/2}+1, N)$ son factores no triviales devolviendo el el factor resultante. En caso contrario el algoritmo falla.
\end{itemize}

\newpage

\section{Conclusión}

En esta sección no mostraremos una conclusión como tal, pues por la naturaleza del trabajo, no se lleva a un resultado que exija su presentación en un conclusión.\\
Sin embargo aprovecharemos esta parte para mostrar algunas impresiones propias sobre el trabajo en vista a lo que se ha hecho.\\
\linebreak
Teniendo en cuenta entonces el área de estudio, podemos decir que ha sido muy interesante ver tanto, soluciones a algunas cuestiones de la computación que se han visto en la propia carrera como las técnicas aplicadas en ella. A pesar de lo sencillo que puede resultar la álgebra lineal en principio, hemos visto que es potente permitiendo a uno resolver incluso problemas con una complejidad elevada.\\
\linebreak
Sin embargo, lamentamos la falta de tanto tiempo como conocimientos para entrar en detalles más profundos y complejos, ya sea en cuestiones de la mecánica cuántica que es de vital importancia, o de cualquier cuestión propia de la computación cuántica que no hemos entrado en detalle. Damos de ejemplo la existencia de puertas universales, como en la última parte donde se desarrollan ideas de la teoría de números. A pesar de todos esto, hacemos notar que ambos libros ofrece fuentes de información para los temas más complejos, ya sea referenciados o en el propio libro.\\
\linebreak
Además también queremos mencionar sobre las implementaciones de los algoritmos. Debido tanto a la falta de conocimientos y también a la falta de recursos las implementaciones están realizadas con un número bajo de qubits por la naturaleza de las simulaciones, donde un número elevado de qubits conlleva un incremento exponencial en el uso de los recursos. Y también queremos hacer notar, quizás lo único que podríamos concluir en este trabajo, es que en las pocas ejecuciones del algoritmo en un ordenador cuántico real hemos visto cómo de erróneo estaba el resultado obtenido. Esto nos muestra que la implementación de los ordenadores cuánticos siguen en desarrollo, teniendo que esperar a estos para poder ver una implementación real de los algoritmos y que sea funcional.\\

\newpage


\nocite{*}

\bibliographystyle{ieeetr}
\bibliography{../../biblio}

\end{document}
